<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[SRM 484C] NumberMagic]]></title>
    <url>%2F2018%2F06%2F15%2FSRM-484C-NumberMagic%2F</url>
    <content type="text"><![CDATA[Description:有$n$个数字，每张卡片上可以写$m$个数字，每次猜一个数字告诉有该数字的卡片编号。问最少几张卡片确定每个数字。 Solution:不难想到二分卡片数$x$，难点在于贪心验证是否可行。验证时枚举数字出现的卡片数，对于每种卡片数$i$每次贪心地尽量多地放数字，也就是$C_{x}^{i}$。 Code:12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;class NumberMagic &#123;public: bool C(int x, int n, int m) &#123; long long ans = 0, c; bool f = 0; for(int i = 0; i &lt;= x; ++i) &#123; if(i == 0) c = 1; else c = c * (x - i + 1) / i; if(c &gt;= n) &#123; f = 1; ans += 1LL * i * n; break; &#125; else ans += c * i, n -= c; &#125; if(!f) return 0; return ans &lt;= 1LL * m * x; &#125; int theMin(int n, int m) &#123; int l = 0, r = n; m = min(m, n - m); while(r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; if(C(mid, n, m)) r = mid; else l = mid; &#125; return r; &#125;&#125;;]]></content>
      <categories>
        <category>TopCoder</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GYM 101630J] Journey from petersburg to Moscow]]></title>
    <url>%2F2018%2F06%2F15%2FGYM-101630J-Journey-from-petersburg-to-Moscow%2F</url>
    <content type="text"><![CDATA[Description:给出一张$n$个点$m$条边的无向图，求只计算前$k$条边长度到$n$的最短路。 Solution:这是一个$wqs$二分模型，运用$wqs$二分思路，给出一个额外的值$w$，每条边的边权变为$max(W-w,0)$,求最短路再加上$k*w$更新答案即可。不过由于码力较差，博主的$wqs$二分并未通过，于是写了枚举边权的版本，复杂度$O(m^2logn)$。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3005;inline int read() &#123; int x = 0; char c = getchar(); while(!isdigit(c)) c = getchar(); while(isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x;&#125;struct Edge &#123; int u, v, w;&#125; E[maxn];struct edge &#123; int nxt, to, w;&#125; e[maxn * 2];int n, m, k, cnt = 1, w;ll ans;int h[maxn];ll d[maxn];void link(int u, int v, int w) &#123; e[++cnt].nxt = h[u]; h[u] = cnt; e[cnt].to = v; e[cnt].w = w;&#125;void D() &#123; priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt; &gt;, greater&lt;pair&lt;ll, int&gt; &gt; &gt; q; memset(d, 0x3f3f, sizeof(d)); d[1] = 0; q.push(make_pair(0, 1)); while(!q.empty()) &#123; pair&lt;ll, int&gt; o = q.top(); q.pop(); int u = o.second; if(d[u] &lt; o.first) continue; for(int i = h[u]; i; i = e[i].nxt) if(d[e[i].to] &gt; d[u] + max(e[i].w - w, 0)) &#123; d[e[i].to] = d[u] + max(e[i].w - w, 0); q.push(make_pair(d[e[i].to], e[i].to)); &#125; &#125;&#125;int main() &#123; n = read(); m = read(); k = read(); for(int i = 1; i &lt;= m; ++i) &#123; E[i].u = read(); E[i].v = read(); E[i].w = read(); link(E[i].u, E[i].v, E[i].w); link(E[i].v, E[i].u, E[i].w); &#125; D(); ans = d[n]; for(int i = 1; i &lt;= m; ++i) &#123; w = E[i].w; D(); ans = min(ans, d[n] + 1LL * w * k); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>GYM</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SRM 599B] FindPolygons]]></title>
    <url>%2F2018%2F06%2F12%2FSRM-599B-FindPolygons%2F</url>
    <content type="text"><![CDATA[Description:给出整数$L$,要求顶点是整点的多边形周长为$L$且在边数最少的情况下最长边减最短边最小。 Solution:首先可以知道边长是整数，因为每条边可以视作直角边为整数的直角三角形的斜边。同时可以证明如果$L$为奇数那么不存在这样的多边形。由于$L$为偶数，那么答案最多为矩形，也就是边的数量最多为$4$，于是我们只要考虑三角形。对于三角形的要求是边长为整数，且坐标为整点。这个条件等价于三角形的面积为整数。于是枚举三条边判断合法即可。 Code:123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;class FindPolygons &#123;public: bool sqr(long long x) &#123; long long t = sqrt(x) + 0.5; return t * t == x; &#125; double minimumPolygon(int L) &#123; if(L == 2) return -1; double ans = 1e9; for(int a = 1; a &lt; L; ++a) for(int b = a; b + a &lt; L; ++b) &#123; int c = L - a - b; if(a + b &gt; c &amp;&amp; c &gt;= b &amp;&amp; sqr(1LL * (a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c))) ans = min(ans, (double)c - a); &#125; if(ans != 1e9) return ans; if(L % 4 == 0) return 0.0; if(L % 2 == 0) return 1.0; return -1; &#125; &#125;;]]></content>
      <categories>
        <category>TopCoder</category>
      </categories>
      <tags>
        <tag>数学技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 3837] Filary]]></title>
    <url>%2F2018%2F06%2F12%2Fbzoj-3837-Filary%2F</url>
    <content type="text"><![CDATA[Description:给定$n$个正整数，从中挑出$k$个数，满足：存在某一个$m(m \geq 2)$，使得这$k$个数模$m$的余数相等。求出$k$的最大值，并求出此时的$m$。如果有多组解使得$k$最大，你要在此基础上求出$m$的最大值。 Solution:由于在$m=2$的情况下至少可以选则一半的数，所以答案至少为$\frac{n}{2}$。考虑随机化，根据上述结论可知期望$log$次随机后即可选中正确的数。将所有数与选中的数做差，那么找出最多的数使得这些数的$gcd$大于等于$1$即是答案。对于每个数枚举质因子，每个质因子单独计算答案即可。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e7 + 5;int n, k, mx;int p[maxn], lp[maxn], a[100005], g[maxn], s[maxn], c[100005];bool mark[maxn];inline char get(void) &#123; static char buf[100000], *S = buf, *T = buf; if (S == T) &#123; T = (S = buf) + fread(buf, 1, 100000, stdin); if (S == T) return EOF; &#125; return *S++;&#125;inline int read() &#123; int x = 0; char c = get(); while(!isdigit(c)) c = get(); while(isdigit(c)) x = x * 10 + c - '0', c = get(); return x;&#125;inline int gcd(int a, int b) &#123; return !b ? a : gcd(b, a % b);&#125;int main() &#123; for(int i = 2; i &lt;= 1e7; ++i) &#123; if(!mark[i]) &#123; p[++p[0]] = i; lp[i] = i; &#125; for(int j = 1; j &lt;= p[0] &amp;&amp; i * p[j] &lt;= 1e7; ++j) &#123; mark[i * p[j]] = 1; lp[i * p[j]] = p[j]; if(i % p[j] == 0) break; &#125; &#125; n = read(); for(int i = 1; i &lt;= n; ++i) a[i] = read(); for(int _ = 1; _ &lt;= 4; ++_) &#123; int t = a[rand() % n + 1]; for(int i = 1; i &lt;= n; ++i) &#123; c[i] = abs(a[i] - t); if(!c[i]) ++s[0]; &#125; for(int i = 1; i &lt;= n; ++i) &#123; int t = c[i]; while(t &gt; 1) &#123; int d = lp[t]; g[d] = gcd(g[d], t); ++s[d]; if(s[d] + s[0] &gt; k) &#123; k = s[d] + s[0]; mx = 0; &#125; if(s[d] + s[0] == k) mx = max(mx, g[d]); while(t % d == 0) t /= d; &#125; &#125; s[0] = 0; for(int i = 1; i &lt;= n; ++i) &#123; int t = c[i]; while(t &gt; 1) &#123; int d = lp[t]; g[d] = 0; s[d] = 0; while(t % d == 0) t /= d; &#125; &#125; &#125; printf("%d %d\n", k, mx); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>数学技巧</tag>
        <tag>随机化</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 990G] GCD Counting]]></title>
    <url>%2F2018%2F06%2F11%2FCodeforces-990G-GCD-Counting%2F</url>
    <content type="text"><![CDATA[Description:对于所有数求路径最大公约数为该数的路径数。 Solution:对于每个数计算最大公约数为该数倍数的路径数，最后利用莫比乌斯反演减去即可。计算的过程是暴力$dfs$，找出所有该数倍数的点$dfs$计算路径数，复杂度较玄学。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5, m = 2e5;inline int read() &#123; int x = 0; char c = getchar(); while(!isdigit(c)) c = getchar(); while(isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x;&#125;int n;int vis[maxn], a[maxn];long long ans[maxn];vector&lt;int&gt; g[maxn], d[maxn], G[maxn];int dfs(int u, int x) &#123; vis[u] = 1; int ret = 1; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(!vis[v] &amp;&amp; a[v] % x == 0) ret += dfs(v, x); &#125; return ret;&#125;int main() &#123; n = read(); for(int i = 1; i &lt;= m; ++i) for(int j = i; j &lt;= m; j += i) d[j].push_back(i); for(int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); for(int j = 0; j &lt; d[a[i]].size(); ++j) g[d[a[i]][j]].push_back(i); &#125; for(int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; for(int i = m; i; --i) &#123; for(int j = 0; j &lt; g[i].size(); ++j) if(!vis[g[i][j]]) &#123; int t = dfs(g[i][j], i); ans[i] += 1LL * t * (t + 1) / 2; &#125; for(int j = 0; j &lt; g[i].size(); ++j) vis[g[i][j]] = 0; for(int j = 2 * i; j &lt;= m; j += i) ans[i] -= ans[j]; &#125; for(int i = 1; i &lt;= m; ++i) if(ans[i]) printf("%d %lld\n", i, ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 700E] Cool Slogans]]></title>
    <url>%2F2018%2F06%2F11%2FCodeforces-700E-Cool-Slogans%2F</url>
    <content type="text"><![CDATA[Description:给你一个长度为$n$的字符串$S$，求最长的一个字符串序列$a_1..a_k$满足序列中的每一个字符串都是$S$的子串，且对于任意的$1&lt;i \leq k$都有$a_{i−1}$在$a_i$中至少出现两次。两次出现允许重叠。 Solution:对$S$建立后缀自动机,我们发现对于一个子串，能被其更新的串的$border$是该子串。考虑对于每个状态计算答案，那么一个状态能被它$parent$树上的祖先更新。每个状态维护$dp[S]$表示该状态最大的等级，线段树维护每个状态的$Right$集合，每个状态记录前继。判断父亲的前继是否在当前状态出现两次，是则更新$+1$,并把前继赋为自己。否则继承父亲的前继。]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[学习笔记] 弦图]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%A6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要介绍有关弦图题目的解法，如果想要更加详细了解弦图，请移步论文。 简介弦是连接环中两个不相邻的点的边，弦图中任意长度大于$3$的环都有至少一个弦。对于有关弦图的题目，主要是关于完美消除序列的运用。 完美消除序列下面给出一些定义:1.单纯点:如果点$u$为单纯点，那么点$u$与其相邻的点$v$构成的诱导子图为团。2.完美消除序列:序列$a_1…a_n$是一个图中顶点编号的排列，对于其中每个序列$a_i…a_n$构成的诱导子图，点$a_i$为单纯点，那么称该序列为完美消除序列。 用于求完美消除序列的最大势算法:设$d_i$为点$i$的度，每次找出$d$最大且未访问的点，取出并将相邻未访问的点的$d$值$+1$，将取出序列翻转即为完美消除序列。可以用堆维护，复杂度$O(mlogn)$,可以通过技巧优化至$O(m+n)$。 例题bzoj1242 Fishing netDescription:判断一个图是否为弦图。 Solution:由于存在完美消除序列和是否为弦图互为充要条件，我们只需要判断是否存在完美消除序列即可。先求出完美消除序列，问题即转化为判断序列是否合法。方法为对于序列中每个点$u$，在序列中且与其相邻的排名最小的点为$v$，那么只要所有排名在$u$之后且与$u$相邻的点同时与$v$相邻即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;inline int read() &#123; int x = 0; char c = getchar(); while(!isdigit(c)) c = getchar(); while(isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x;&#125;int n, m, ans;priority_queue&lt;pair&lt;int, int&gt; &gt; q;vector&lt;int&gt; G[maxn], vec, t;set&lt;pair&lt;int, int&gt; &gt; s;int vis[maxn], d[maxn], a[maxn], rnk[maxn];int main() &#123; n = read(); m = read(); for(int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); s.insert(make_pair(u, v)); s.insert(make_pair(v, u)); &#125; for(int i = 1; i &lt;= n; ++i) q.push(make_pair(0, i)); while(!q.empty()) &#123; pair&lt;int, int&gt; o = q.top(); q.pop(); int u = o.second; if(vis[u]) continue; vis[u] = 1; vec.push_back(u); for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(vis[v]) continue; ++d[v]; q.push(make_pair(d[v], v)); &#125; &#125; reverse(vec.begin(), vec.end()); for(int i = 0; i &lt; vec.size(); ++i) rnk[vec[i]] = i; for(int i = 0; i &lt; n; ++i) &#123; int u = vec[i]; t.clear(); for(int j = 0; j &lt; G[u].size(); ++j) &#123; int v = G[u][j]; if(rnk[v] &gt; rnk[u]) t.push_back(rnk[v]); &#125; sort(t.begin(), t.end()); for(int j = 1; j &lt; t.size(); ++j) &#123; int v = vec[t[j]]; if(s.find(make_pair(vec[t[0]], v)) == s.end()) &#123; puts("Imperfect"); return 0; &#125; &#125; &#125; puts("Perfect"); return 0;&#125; bzoj1006 神奇的国度Description:求弦图的最小染色数。 Solution:完美消除序列从后往前贪心染色。 Code:12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;inline int read() &#123; int x = 0; char c = getchar(); while(!isdigit(c)) c = getchar(); while(isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x;&#125;int n, m, ans;priority_queue&lt;pair&lt;int, int&gt; &gt; q;vector&lt;int&gt; G[maxn];int vis[maxn], d[maxn], a[maxn];int main() &#123; n = read(); m = read(); for(int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; for(int i = 1; i &lt;= n; ++i) q.push(make_pair(0, i)); while(!q.empty()) &#123; pair&lt;int, int&gt; o = q.top(); q.pop(); int u = o.second; if(vis[u]) continue; vis[u] = 1; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(vis[v]) continue; ++d[v]; q.push(make_pair(d[v], v)); &#125; &#125; for(int i = 1; i &lt;= n; ++i) a[d[i]] = 1; for(int i = 0; i &lt;= n; ++i) ans += a[i]; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>弦图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 3698] XWW的难题]]></title>
    <url>%2F2018%2F06%2F06%2Fbzoj-3698-XWW%E7%9A%84%E9%9A%BE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Description:给出一个$n*n$的矩阵，矩阵中每个元素可以上取整或下取整。要求出最后一行一列每一行每一列前$n-1$个元素之和等于最后一个元素，且所有元素之和最大。 Solution:把行列分别建点，如果某个元素不是整数意味着可以上取整。对应行向列连边。现在要求求上下界最大流。以下是解决上下界最大流的方法:1.建图原图中边的容量视为上界减下界，设立超级源汇，如果一个点进入的流量大于出去额流量，则由超级源连向该点，容量为差值，否则连向超级汇，容量为差值的相反数，再从汇向源连一条容量为$inf$的边。2.操作先由超级源汇跑出可行流，再从源汇跑最大流即是答案。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 305, inf = 1e9;struct edge &#123; int nxt, to, f;&#125; e[maxn * maxn * 10];int n, source, sink, S, T, cnt = 1, tot;int h[maxn], iter[maxn], in[maxn], d[maxn], deg[maxn];double a[105][105];void link(int u, int v, int f) &#123; e[++cnt].nxt = h[u]; h[u] = cnt; e[cnt].to = v; e[cnt].f = f;&#125;void insert(int u, int v, int f) &#123; link(u, v, f); link(v, u, 0);&#125;int dfs(int u, int sink, int delta) &#123; if(u == sink) return delta; int ret = 0; for(int &amp;i = iter[u]; i &amp;&amp; delta; i = e[i].nxt) if(d[e[i].to] == d[u] + 1 &amp;&amp; e[i].f) &#123; int x = dfs(e[i].to, sink, min(e[i].f, delta)); e[i].f -= x; e[i ^ 1].f += x; ret += x; delta -= x; &#125; return ret;&#125;bool bfs(int source, int sink) &#123; queue&lt;int&gt; q; memset(d, -1, sizeof(d)); q.push(source); d[source] = 0; while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = h[u]; i; i = e[i].nxt) if(d[e[i].to] == -1 &amp;&amp; e[i].f)&#123; d[e[i].to] = d[u] + 1; q.push(e[i].to); &#125; &#125; return ~d[sink];&#125;int dinic(int source, int sink) &#123; int ret = 0; while(bfs(source, sink)) &#123; for(int i = 0; i &lt; maxn; ++i) iter[i] = h[i]; ret += dfs(source, sink, inf); &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) scanf("%lf", &amp;a[i][j]); sink = 2 * n + 1; S = 2 * n + 2; T = 2 * n + 3; for(int i = 1; i &lt;= n; ++i) &#123; if(a[i][n] != (int)a[i][n]) insert(source, i, 1); if(a[n][i] != (int)a[n][i]) insert(i + n, sink, 1); deg[source] -= (int)a[i][n]; deg[i] += (int)a[i][n]; deg[i + n] -= (int)a[n][i]; deg[sink] += (int)a[n][i]; &#125; for(int i = 1; i &lt; n; ++i) for(int j = 1; j &lt; n; ++j) &#123; if(a[i][j] != (int)a[i][j]) insert(i, j + n, 1); deg[i] -= (int)a[i][j]; deg[j + n] += (int)a[i][j]; &#125; for(int i = 0; i &lt;= sink; ++i) if(deg[i] &gt; 0) &#123; tot += deg[i]; insert(S, i, deg[i]); &#125; else insert(i, T, -deg[i]); insert(sink, source, inf); if(dinic(S, T) != tot) &#123; puts("No"); return 0; &#125; printf("%d\n", dinic(source, sink) * 3); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的对拍]]></title>
    <url>%2F2018%2F06%2F06%2FLinux%E4%B8%8B%E7%9A%84%E5%AF%B9%E6%8B%8D%2F</url>
    <content type="text"><![CDATA[数据生成器12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen("data.in", "w", stdout); //数据生成器 fclose(stdout); return 0;&#125; 正解 &amp; 暴力12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen("data.in", "r", stdin); freopen("1.out", "w", stdout); //正解 fclose(stdin); fclose(stdout); return 0;&#125; 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen("data.in", "r", stdin); freopen("2.out", "w", stdout); //暴力 fclose(stdin); fclose(stdout); return 0;&#125; 对拍器1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; while(1) &#123; system("./data"); system("./1"); system("./2"); if(system("diff 1.out 2.out")) &#123; system("pause"); break; &#125; else puts("AC"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 4550] 小奇的博弈]]></title>
    <url>%2F2018%2F06%2F06%2Fbzoj-4550-%E5%B0%8F%E5%A5%87%E7%9A%84%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[Description:$1*n$的棋盘上有$k$个棋子，一半为黑色另一半为白色。每次可以移动$[1,d]$个某种颜色的棋子，且黑色只能向右，白色只能向左，如果不能移动则输，问使黑棋先手获胜的初始棋局数。 Solution:把黑白棋子两两配对，空隙看作石子，那么相当于每个人每次可以在$[1,d]$堆中取石子。于是问题转化成了$K-nim$游戏。$K-nim$游戏先手获胜的条件是所有石子每个二进制位之和能被$k+1$整除，那么考虑$dp$。$dp[i][j]$表示前$i$对石子用了$j$个位置的方案数， 转移即可。 Code:1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5, P = 1e9 + 7;inline int read() &#123; int x = 0; char c = getchar(); while(!isdigit(c)) c = getchar(); while(isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x;&#125;void u(int &amp;x, int y) &#123; x = (x + y) % P; &#125;int n, k, d;int c[maxn][105], dp[16][maxn];int main() &#123; n = read(); k = read() / 2; d = read(); c[0][0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; c[i][0] = 1; for(int j = 1; j &lt;= min(2 * k, i); ++j) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % P; &#125; dp[0][0] = 1; for(int i = 0; i &lt; 15; ++i) for(int j = 0; j &lt;= n - 2 * k; ++j) for(int K = 0; K * (d + 1) * (1 &lt;&lt; i) + j &lt;= n &amp;&amp; K * (d + 1) &lt;= k; ++K) u(dp[i + 1][j + K * (d + 1) * (1 &lt;&lt; i)], 1LL * dp[i][j] * c[k][K * (d + 1)] % P); int ans = 0; for(int i = 0; i &lt;= n - 2 * k; ++i) u(ans, 1LL * dp[15][i] * c[n - i - k][k] % P); printf("%d\n", (c[n][2 * k] - ans + P) % P); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 5329] 战略游戏]]></title>
    <url>%2F2018%2F06%2F06%2Fbzoj-5329-%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[Description:给出一棵$n$个点的树，每次选出一些点，询问除给出点之外哪些点删除会导致给出点不连通。 Solution:先将原树建成割点树，每次即询问给出点路径上的割点个数。预处理每个点到根割点数量，在虚树上计算一下即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 4e5 + 5;int n, m, dfs_clock, cnt, Top, q, ans; vector&lt;int&gt; G[maxn], g[maxn * 2];int st[maxn * 2], son[maxn], dep[maxn], dis[maxn], low[maxn], dfn[maxn], fa[maxn], top[maxn], a[maxn * 2], sz[maxn], in[maxn], out[maxn];void tarjan(int u, int f) &#123; dfn[u] = low[u] = ++dfs_clock; st[++Top] = u; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(v == f) continue; if(!dfn[v]) &#123; tarjan(v, u); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u]) &#123; ++cnt; while(st[Top + 1] != v) &#123; g[cnt].push_back(st[Top]); g[st[Top]].push_back(cnt); --Top; &#125; g[cnt].push_back(u); g[u].push_back(cnt); &#125; &#125; else low[u] = min(low[u], dfn[v]); &#125;&#125;int lca(int u, int v) &#123; while(top[u] != top[v]) &#123; if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fa[top[u]]; &#125; return dep[u] &lt; dep[v] ? u : v;&#125;void dfs(int u, int f) &#123; sz[u] = 1; son[u] = 0; dis[u] = dis[f] + (u &lt;= n); for(int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if(v == f) continue; dep[v] = dep[u] + 1; fa[v] = u; dfs(v, u); sz[u] += sz[v]; if(sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125;void dfs(int u, int f, int t) &#123; top[u] = t; in[u] = ++dfs_clock; if(son[u]) dfs(son[u], u, t); for(int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if(v == f || v == son[u]) continue; dfs(v, u, v); &#125; out[u] = dfs_clock;&#125;bool cmp(int i, int j) &#123; return in[i] &lt; in[j]; &#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low)); memset(st, 0, sizeof(st)); scanf("%d%d", &amp;n, &amp;m); dfs_clock = 0; for(int i = 1; i &lt;= n; ++i) G[i].clear(); for(int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; cnt = n; tarjan(1, 0); dfs_clock = 0; dfs(1, 0); dfs(1, 0, 1); scanf("%d", &amp;q); while(q--) &#123; int tot; scanf("%d", &amp;tot); ans = -tot; for(int i = 1; i &lt;= tot; ++i) &#123; scanf("%d", &amp;a[i]); &#125; sort(a + 1, a + tot + 1, cmp); for(int i = tot; i &gt; 1; --i) a[++tot] = lca(a[i], a[i - 1]); sort(a + 1, a + tot + 1, cmp); tot = unique(a + 1, a + tot + 1) - a - 1; int top = 0; for(int i = 1; i &lt;= tot; ++i) &#123; while(top &amp;&amp; !(in[st[top]] &lt;= in[a[i]] &amp;&amp; out[st[top]] &gt;= out[a[i]])) --top; if(top) ans += dis[fa[a[i]]] - dis[st[top]]; st[++top] = a[i]; &#125; for(int i = 1; i &lt;= tot; ++i) if(a[i] &lt;= n) ++ans; printf("%d\n", ans); &#125; for(int i = 1; i &lt;= cnt; ++i) g[i].clear(); &#125; return 0;&#125; 考$APIO$时忘记了求割点，如果记得就发财了。]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>虚树</tag>
        <tag>tarjan &amp; 联通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 3925] 地震后的幻想乡]]></title>
    <url>%2F2018%2F06%2F06%2Fbzoj-3925-%E5%9C%B0%E9%9C%87%E5%90%8E%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[Description:给出一张$n$个点$m$条边的图，每条边的边权是均匀分布在$[0,1]$的实数。求期望最小生成树最大边权。 Solution:由于写完之后忘记保存，于是博主不准备再写一遍，附上一个不错的题解。 Code:123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 11, maxm = 55;int n, m;double ans;long long c[55][55], cnt[1 &lt;&lt; maxn], e[maxn], tmp[1 &lt;&lt; maxn], f[1 &lt;&lt; maxn][maxm], g[1 &lt;&lt; maxn][maxm];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); --u; --v; e[u] |= 1 &lt;&lt; v; e[v] |= 1 &lt;&lt; u; &#125; c[0][0] = 1; for(int i = 1; i &lt;= m; ++i) &#123; c[i][0] = 1; for(int j = 1; j &lt;= i; ++j) c[i][j] = c[i - 1][j - 1] + c[i - 1][j]; &#125; for(int i = 0; i &lt; 1 &lt;&lt; n; ++i) cnt[i] = __builtin_popcount(i); for(int S = 1; S &lt; 1 &lt;&lt; n; ++S) &#123; if(cnt[S] == 1) &#123; g[S][0] = 1; continue; &#125; for(int i = 0; i &lt; n; ++i) if(S &gt;&gt; i &amp; 1) tmp[S] += cnt[S &amp; e[i]]; tmp[S] &gt;&gt;= 1; int t = S &amp; -S; for(int S0 = (S - 1) &amp; S; S0; S0 = (S0 - 1) &amp; S) if(S0 &amp; t) for(int i = 0; i &lt;= tmp[S0]; ++i) for(int j = 0; j &lt;= tmp[S ^ S0]; ++j) f[S][i + j] += g[S0][i] * c[tmp[S ^ S0]][j]; for(int i = 0; i &lt;= tmp[S]; ++i) g[S][i] = c[tmp[S]][i] - f[S][i]; &#125; for(int i = 0; i &lt;= m; ++i) ans += (double)f[(1 &lt;&lt; n) - 1][i] / c[tmp[(1 &lt;&lt; n) - 1]][i]; ans /= m + 1; printf("%.6f\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[故事]]></title>
    <url>%2F2018%2F06%2F05%2F%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX18sPC32WVhpDhcLq1T84W6TNJ4SeP6uV/ZqNaItpt0wdXUmh8e/5O/HpvvFUVXrW+uamO9fgR9Xdvzl3LKezAVkxSw1XfBhWYKKMUeKMvnDrnUpVXhXPxi0sV37Wm3oHg9V9+Eg0uS6Qy/s/YcMoySa82Oeq9mDjw+zbj32eLJfoUZNkZ6NHHBx var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 827E] Rusty String]]></title>
    <url>%2F2018%2F06%2F04%2FCodeforces-827E-Rusty-String%2F</url>
    <content type="text"><![CDATA[Description:求带通配符字符串的循环节。 Solution:考虑求循环节的方法，求出$kmp$的$nxt$数组,那么答案就是$n-nxt$。由于有通配符，所以不能使用$kmp$，于是通过$FFT$计算。两个数组中分别把$V$和$K$标记为$1$，做$FFT$，如果一个位置的和为$0$那么意味着这个长度不是循环节，那么长度的约数也不是循环节，于是找出未被标记的长度即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6 + 5;const double pi = acos(-1), eps = 1e-5;struct cp &#123; double x, y; cp() &#123;&#125; cp(double _x, double _y) : x(_x), y(_y) &#123;&#125; inline cp friend operator + (const cp &amp;a, const cp &amp;b) &#123; return cp(a.x + b.x, a.y + b.y); &#125; inline cp friend operator - (const cp &amp;a, const cp &amp;b) &#123; return cp(a.x - b.x, a.y - b.y); &#125; inline cp friend operator * (const cp &amp;a, const cp &amp;b) &#123; return cp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;&#125; a[maxn], b[maxn];int n, m, len;char s[maxn];bool can[maxn];void FFT(cp *a, int f) &#123; for(int i = 0; i &lt; n; ++i) &#123; int t = 0; for(int j = 0; j &lt; len; ++j) if(i &gt;&gt; j &amp; 1) t |= 1 &lt;&lt; (len - j - 1); if(i &lt; t) swap(a[i], a[t]); &#125; for(int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; int m = l &gt;&gt; 1; cp w = cp(cos(pi / m), f * sin(pi / m)); for(int i = 0; i &lt; n; i += l) &#123; cp t = cp(1, 0); for(int k = 0; k &lt; m; ++k, t = t * w) &#123; cp x = a[i + k], y = t * a[i + m + k]; a[i + k] = x + y; a[i + m + k] = x - y; &#125; &#125; &#125; if(f == -1) for(int i = 0; i &lt; n; ++i) a[i].x /= n;&#125;void init() &#123; scanf("%d%s", &amp;m, s); n = 1; len = 0; while(n &lt;= m * 2) n &lt;&lt;= 1, ++len; for(int i = 0; i &lt; n; ++i) a[i] = b[i] = cp(0, 0), can[i] = 0; for(int i = 0; i &lt; m; ++i) if(s[i] == 'V') a[i].x = 1; else if(s[i] == 'K') b[m - i - 1].x = 1;&#125;void solve() &#123; FFT(a, 1); FFT(b, 1); for(int i = 0; i &lt; n; ++i) a[i] = a[i] * b[i]; FFT(a, -1); for(int i = 0; i &lt; n; ++i) if(fabs(a[i].x) &gt;= eps) &#123; can[abs(i - m + 1)] = 1; &#125; for(int i = 1; i &lt; m; ++i) if(!can[i]) for(int j = i &lt;&lt; 1; j &lt; m; j += i) if(can[j]) &#123; can[i] = 1; break; &#125; int ans = 0; for(int i = 1; i &lt;= m; ++i) if(!can[i]) ++ans; printf("%d\n", ans); for(int i = 1; i &lt;= m; ++i) if(!can[i]) printf("%d ", i); puts("");&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>多项式 &amp; 生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 3729] Gty的游戏]]></title>
    <url>%2F2018%2F06%2F03%2Fbzoj-3729-Gty%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[Description:给出一棵$n$个点的树，每个节点上有一些石子，有以下三种操作:1.给出节点$u$，每次可以将$u$的子树中节点石子向上移动不超过$L$颗，最后不可操作者输。问输赢。2.修改某个节点上石子个数。3.给某个点添加一个儿子。 Solution:分别考虑三种操作:1.发现等价于将所有石子模$L+1$后玩阶梯$nim$。维护子树内奇偶深度异或和即可。2.$Splay$旋转出点，修改石子数即可。3.由于有加点操作，并且需要维护子树，考虑使用$ETT$维护。在点$u$下添加点$v$，$Splay$上找出点$u$的后继$nxt$，在$u$与$nxt$之间插入点$v$即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;inline int read() &#123; int x = 0; char c = getchar(); while(!isdigit(c)) c = getchar(); while(isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x;&#125;struct node &#123; int v, f; int ch[2], sg[2];&#125; t[maxn];int n, m, k, ans, root, dfs_clock;int in[maxn], out[maxn], a[maxn], dep[maxn], to[maxn];vector&lt;int&gt; G[maxn];inline void upd(int x) &#123; t[x].sg[0] = t[t[x].ch[0]].sg[0] ^ t[t[x].ch[1]].sg[0]; t[x].sg[1] = t[t[x].ch[0]].sg[1] ^ t[t[x].ch[1]].sg[1]; t[x].sg[dep[abs(to[x])]] ^= t[x].v;&#125;inline int wh(int x) &#123; return x == t[t[x].f].ch[1]; &#125;void rotate(int x) &#123; int y = t[x].f, z = t[y].f, w = wh(x); t[x].f = z; t[z].ch[wh(y)] = x; t[t[x].ch[w ^ 1]].f = y; t[y].ch[w] = t[x].ch[w ^ 1]; t[x].ch[w ^ 1] = y; t[y].f = x; upd(y); upd(x);&#125;inline void splay(int x, int f) &#123; for(; t[x].f != f; rotate(x)) if(t[t[x].f].f != f) rotate(wh(t[x].f) == wh(x) ? t[x].f : x); if(!f) root = x;&#125;void dfs(int u, int f) &#123; in[u] = ++dfs_clock; to[in[u]] = u; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(v == f) continue; dep[v] = dep[u] ^ 1; dfs(v, u); &#125; out[u] = ++dfs_clock; to[out[u]] = -u; &#125;void build(int l, int r, int &amp;x, int f) &#123; if(l &gt; r) return; int mid = (l + r) &gt;&gt; 1; t[x = mid].f = f; t[x].v = to[x] &gt; 0 ? a[to[x]] : 0; build(l, mid - 1, t[x].ch[0], x); build(mid + 1, r, t[x].ch[1], x); upd(x);&#125;inline int query(int x) &#123; int a = in[x], b = out[x]; splay(a, 0); splay(b, a); return t[t[b].ch[0]].sg[dep[x] ^ 1] &gt; 0;&#125;inline int nxt(int x) &#123; x = t[x].ch[1]; while(t[x].ch[0]) x = t[x].ch[0]; return x;&#125;void add(int x, int y, int z) &#123; to[in[y] = ++dfs_clock] = y; to[out[y] = ++dfs_clock] = -y; dep[y] = dep[x] ^ 1; int a = in[y], b = out[y]; t[a].v = z; t[a].ch[1] = b; t[b].f = a; splay(in[x], 0); int p = nxt(in[x]); splay(p, in[x]); t[p].ch[0] = a; t[a].f = p; upd(b); upd(a); upd(p); upd(in[x]);&#125;inline void cha(int x, int y) &#123; splay(in[x], 0); t[in[x]].v = y; upd(in[x]);&#125;int main() &#123;// freopen("nim_tree4.in", "r", stdin);// freopen("1.out", "w", stdout); n = read(); k = read() + 1; for(int i = 1; i &lt;= n; ++i) a[i] = read() % k; for(int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); build(1, dfs_clock, root, 0); m = read(); while(m--) &#123; int opt = read(), x = read() ^ ans, y, T; if(opt == 1) &#123; int t = query(x); ans += t; printf(t ? "MeiZ\n" : "GTY\n"); &#125; else if(opt == 2) &#123; y = read() ^ ans; cha(x, y % k); &#125; else &#123; y = read() ^ ans; T = read() ^ ans; add(x, y, T % k); &#125; &#125;// fclose(stdin);// fclose(stdout); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>平衡树</tag>
        <tag>ETT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 4945] 游戏]]></title>
    <url>%2F2018%2F06%2F03%2Fbzoj-4945-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[Description:给出一张地图，如果某个位置上的标记不为$x$则表示该位置不能使用编号为标记的赛车，是$x$则表示可以任意选。再给出$m$条关系，表示如果某个位置选了某种赛车那么另外一个位置必须选择另外一种赛车。输出方案。 Solution:可以看出本题是一个$3-SAT$问题。$3-SAT$问题是$NPC$问题，不能解决。发现$x$的数量很少，于是枚举每个$x$位置的标记，表示不能选这种赛车，问题转化为了$2-SAT$问题。考虑如何添加关系。每个位置拆成两个点，表示选了哪种赛车。给出的$m$条关系中可以直接添加，还需要添加这些关系的逆否命题。最后输出方案，发现$tarjan$后的编号就是拓扑序，直接输出即可。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int n, m, dfs_clock, top, tot;int bel[maxn], dfn[maxn], low[maxn], st[maxn], vis[maxn], a[maxn], b[maxn], c[maxn], d[maxn];char s[maxn];vector&lt;int&gt; G[maxn];void tarjan(int u) &#123; dfn[u] = low[u] = ++dfs_clock; vis[u] = 1; st[++top] = u; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(vis[v]) low[u] = min(low[u], low[v]); &#125; if(dfn[u] == low[u]) &#123; ++tot; while(st[top + 1] != u) &#123; bel[st[top]] = tot; vis[st[top]] = 0; --top; &#125; &#125;&#125;int get(int a, int b) &#123; if(s[a] == 'a') return b == 0 ? 0 : 2 * a + b - 1; else if(s[a] == 'b') return b == 1 ? 0 : 2 * a + b / 2; else return b == 2 ? 0 : 2 * a + b;&#125;bool solve() &#123; dfs_clock = 0; tot = 0; memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low)); for(int i = 1; i &lt;= 2 * n + 1; ++i) G[i].clear(); for(int i = 1; i &lt;= m; ++i) &#123; int x = get(a[i], c[i]), y = get(b[i], d[i]); if(x) &#123; if(y) &#123; G[x].push_back(y); G[y ^ 1].push_back(x ^ 1); &#125; else &#123; G[x].push_back(x ^ 1); &#125; &#125; &#125; for(int i = 2; i &lt;= 2 * n + 1; ++i) if(!dfn[i]) tarjan(i); for(int i = 1; i &lt;= n; ++i) if(bel[i &lt;&lt; 1] == bel[i &lt;&lt; 1 | 1]) return 0; for(int i = 1; i &lt;= n; ++i) &#123; if(s[i] == 'a') putchar(bel[i &lt;&lt; 1] &lt; bel[i &lt;&lt; 1 | 1] ? 'B' : 'C'); else if(s[i] == 'b') putchar(bel[i &lt;&lt; 1] &lt; bel[i &lt;&lt; 1 | 1] ? 'A' : 'C'); else putchar(bel[i &lt;&lt; 1] &lt; bel[i &lt;&lt; 1 | 1] ? 'A' : 'B'); &#125; return 1;&#125;bool dfs(int d) &#123; if(d == n + 1) return solve(); if(s[d] == 'x') &#123; s[d] = 'a'; if(dfs(d + 1)) return 1; s[d] = 'b'; &#125; return dfs(d + 1);&#125;int main() &#123; scanf("%d%*d%s%d", &amp;n, s + 1, &amp;m); for(int i = 1; i &lt;= m; ++i) &#123; char s1[10], s2[10]; scanf("%d%s%d%s", &amp;a[i], s1, &amp;b[i], s2); c[i] = s1[0] - 'A'; d[i] = s2[0] - 'A'; &#125; if(!dfs(1)) puts("-1"); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 4946] 蔬菜]]></title>
    <url>%2F2018%2F06%2F02%2Fbzoj-4946-%E8%94%AC%E8%8F%9C%2F</url>
    <content type="text"><![CDATA[Description:有$n$种蔬菜，第i种蔬菜每天变质$x_i$个单位，第一次购买第$i$种蔬菜有$s_i$的附加价值，每个单位蔬菜有$a_i$价值，共有$s_i$个单位蔬菜。每天最多卖掉$m$个单位个蔬菜。多组询问$m$天时间内获得的最大价值。 Solution:首先有一个较显然的费用流做法，倒着建图即可，考场上写出这种做法即可获得不少分数，性价比较高。 考虑正解，仍然倒着解决问题。建立一个大根堆，将每个加上附加价值的物品放入堆里，每次取一个物品，相当于模拟原来的过程。每次取出最大的物品，并考虑这个物品的后继物品，通过并查集维护当前时间上一个可以出售物品的日子，把要放入堆的物品预定到找到的日子。当前选择的物品一定是可选的价值最大的，那么我们自然希望尽量多地选同类物品，所以可以保证正确性。 时间复杂度$O(nmlogn)$ Code:12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;inline char get(void) &#123; static char buf[100000], *S = buf, *T = buf; if (S == T) &#123; T = (S = buf) + fread(buf, 1, 100000, stdin); if (S == T) return EOF; &#125; return *S++;&#125;inline int read() &#123; int x = 0; char c = get(); while(!isdigit(c)) c = get(); while(isdigit(c)) x = x * 10 + c - '0', c = get(); return x;&#125;int n, m, Q, t, s, p;priority_queue&lt;pair&lt;int, int&gt; &gt; q;int a[maxn], c[maxn], r[maxn], fa[maxn], b[maxn];long long ans[maxn];inline int find(int x) &#123; return x == fa[x] ? x : fa[x] = find(fa[x]); &#125;int main() &#123; n = read(); m = read(); Q = read(); for(int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); s = read(); c[i] = read(); r[i] = read(); q.push(make_pair(a[i] + s, i)); &#125; for(int i = 1; i &lt; maxn; ++i) fa[i] = i, b[i] = m; while(!q.empty()) &#123; int x = q.top().first, y = q.top().second; q.pop(); p = find(r[y] ? min((c[y] + r[y] - 1) / r[y], maxn - 1) : maxn - 1); if(!p) continue; --c[y]; --b[p]; if(!b[p]) fa[find(p)] = find(p - 1); if(c[y]) q.push(make_pair(a[y], y)); ++t; ans[t] = ans[t - 1] + x; &#125; while(Q--) printf("%lld\n", ans[min(read() * m, t)]); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 5206] 原力]]></title>
    <url>%2F2018%2F06%2F01%2Fbzoj-5206-%E5%8E%9F%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[Description:给出一张$n$个点$m$条边的无向图，每条条边有权值和颜色，共有三种不同颜色。求所有包含三种颜色三元环边权积的和。 Solution:使用根号分治，对于度数大于$\sqrt{n}$的点分成一类，枚举其中三点计算答案。由于这样的点的数量不超过$\sqrt{n}$,复杂度为$O(n\sqrt{n})$。对于度数小于等于$\sqrt{n}$的点，枚举这样的点以及两条出边计算答案，要求当前点枚举的出边连的点接编号大于当前点或者度数$\sqrt{n}$才统计答案，能做到不重不漏。枚举第一条边的总复杂度可以视为边的数量，第二条边枚举的复杂度小于等于$\sqrt{n}$,所以总复杂度为$O(m\sqrt{n})$。过程中要求对边进行存储，把$map$当成哈希表即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5, P = 1e9 + 7;struct edge &#123; int nxt, to, t, w;&#125; e[maxn * 2];struct data &#123; int u, v, t; data() &#123;&#125; data(int _u, int _v, int _t) : u(_u), v(_v), t(_t) &#123;&#125; inline bool friend operator &lt; (const data &amp;a, const data &amp;b) &#123; if(a.u != b.u) return a.u &lt; b.u; if(a.v != b.v) return a.v &lt; b.v; return a.t &lt; b.t; &#125; &#125;;int n, m, top, ans, cnt = 1;map&lt;data, int&gt; mp;int d[maxn], h[maxn], st[maxn];inline int read() &#123; int x = 0; char c = getchar(); while(!isdigit(c)) c = getchar(); while(isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x;&#125;void link(int u, int v, int w, int t) &#123; e[++cnt].nxt = h[u]; h[u] = cnt; e[cnt].to = v; e[cnt].w = w; e[cnt].t = t;&#125;int main() &#123; n = read(); m = read(); for(int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(), w = read(), t; char c = getchar(); while(c &lt; 'A' || c &gt; 'Z') c = getchar(); if(c == 'R') t = 1; else if(c == 'G') t = 2; else t = 3; mp[data(u, v, t)] = (mp[data(u, v, t)] + w) % P; mp[data(v, u, t)] = (mp[data(v, u, t)] + w) % P; link(u, v, w, t); link(v, u, w, t); ++d[u]; ++d[v]; &#125; int B = sqrt(n); for(int i = 1; i &lt;= n; ++i) if(d[i] &gt;= B) st[++top] = i; for(int i = 1; i &lt;= top; ++i) for(int j = 1; j &lt;= top; ++j) for(int k = 1; k &lt;= top; ++k) &#123; ans = (ans + 1LL * mp[data(st[i], st[j], 1)] * mp[data(st[i], st[k], 2)] % P * mp[data(st[j], st[k], 3)] % P) % P; &#125; for(int i = 1; i &lt;= n; ++i) if(d[i] &lt; B) for(int j = h[i]; j; j = e[j].nxt) if(e[j].to &gt; i || d[e[j].to] &gt;= B) &#123; for(int k = e[j].nxt; k; k = e[k].nxt) if(e[j].t != e[k].t &amp;&amp; (e[k].to &gt; i || d[e[k].to] &gt;= B)) &#123; ans = (ans + 1LL * e[j].w * e[k].w % P * mp[data(e[j].to, e[k].to, 6 - e[j].t - e[k].t)] % P) % P; &#125; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>hash</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 1815] color 有色图]]></title>
    <url>%2F2018%2F06%2F01%2Fbzoj-1815-color-%E6%9C%89%E8%89%B2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Description:给出$m$种颜色，图的每条边可以选一种颜色，问有多少本质不同的图。 Solution:考虑使用$Pólya$定理，问题转化成求出每个置换的循环节数。置换的个数是$n!$,显然不能枚举。经过观察，由于我们求的是关于边的循环节，又每个点的置换对应了边的置换，发现本质不同边的置换是很少的，在$n=53$的情况下仅有不到$300000$种情况，且这些点置换的结构满足可以分解成若干循环$L_1,L_2…L_n,L_1 \leq L_2 \leq … \leq L_n$。先将所有符合的结构搜索出来，对于每一种单独计算，问题转化为给定点置换求边的循环节个数。对于两个循环之间的边，循环节个数为$gcd(L_i,L_j)$,同一个循环内的循环节个数则为$[\frac{L_i}{2}]$,同时对于每种结构还要乘上这种结构的个数，为 \frac{n!}{\prod_{i=1}^{n}{L_i}\prod{cnt_i!}}$cnt_i$表示$L_i$相同的个数，式子的意义为把循环看做圆排列，需要除以排列长度，还需除以相同大小的循环的顺序。 这道题属于比较难的置换群问题，难点在于对于边与点置换的计算，没有完全搞懂，还需思考。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 55;int n, m, p;ll ans;int a[maxn];ll inv[maxn], fac[maxn], facinv[maxn], Gcd[maxn][maxn], pw[maxn * maxn];ll power(ll x, ll t) &#123; ll ret = 1; for(; t; t &gt;&gt;= 1, x = x * x % p) if(t &amp; 1) ret = ret * x % p; return ret;&#125; int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a; &#125;ll solve(int tot) &#123; ll ret = 1, cnt = 1, ans = 0; for(int i = 1; i &lt;= tot; ++i) ret = ret * inv[a[i]] % p; for(int i = tot - 1; ~i; --i) &#123; if(a[i] != a[i + 1]) &#123; ret = ret * facinv[cnt] % p; cnt = 1; &#125; else ++cnt; &#125; for(int i = 1; i &lt;= tot; ++i) ans += a[i] &gt;&gt; 1; for(int i = 1; i &lt;= tot; ++i) for(int j = 1; j &lt; i; ++j) ans += Gcd[a[i]][a[j]]; return ret * pw[ans] % p;&#125;void dfs(int d, int res, int last) &#123; if(res == 0) &#123; ans = (ans + solve(d - 1)) % p; return; &#125; for(int i = last; i &lt;= res; ++i) &#123; a[d] = i; dfs(d + 1, res - i, i); &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;p); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) Gcd[i][j] = gcd(i, j); pw[0] = 1; for(int i = 1; i &lt;= n * n; ++i) pw[i] = pw[i - 1] * m % p; fac[0] = 1; inv[0] = 1; facinv[0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; fac[i] = fac[i - 1] * i % p; inv[i] = power(i, p - 2); facinv[i] = facinv[i - 1] * inv[i] % p; &#125; dfs(1, n, 1); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>置换群</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[学习笔记] Burnside引理 & Pólya定理]]></title>
    <url>%2F2018%2F06%2F01%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Burnside%E5%BC%95%E7%90%86-Polya%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[简介用来解决有关置换的计数问题。 Burnside引理$Burnside$引理可以用来计算等价类数目，这也是经常碰见的一类题目。$Burnside$引理公式: L=\frac{1}{n}{\sum_{i=1}^{n}{c(a_i)}}$n$表示不同置换个数，$a_i$表示第$i$个置换，$c(a_i)$表示经过置换$a_i$下颜色不变的方案数,这里的颜色表示的是每个元素的特征，用元素来指代。于是比较困难的原问题转化为求出对于每个置换$a_i$的$c(a_i)$， Pólya定理通俗的来讲，$Pólya$定理是用来辅助$Burnside$引理求出每个$a_i$的$c(a_i)$。$Pólya$定理公式: L=\frac{1}{n}\sum_{i=1}^{n}{m^{\lambda(a_i)}}$m$表示总的颜色个数，$\lambda(a_i)$表示置换$a_i$的循环节个数。由于要求经过置换后颜色不变，一个循环节自然要染同样的颜色。现在问题变得简单了，只需要找出每种置换的循环节数量即可解决问题。 例题1.$Burnside$引理bzoj1004Description:给出三种颜色数量以及一些置换，问等价类数目。Solution:套用$Burnside$引理，问题在于求出每个置换$a_i$的$c(a_i)$。由于颜色数目有限制，不能套用$Pólya$定理，经过分析，对于一个循环节需要染同样的颜色。于是对于每个置换求出循环节，做背包$dp$计算方案即可。code:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 75;int n, m, a, b, c, p, tot;ll ans;int vis[maxn], nxt[maxn], s[maxn];ll dp[maxn][maxn][maxn];ll Dp() &#123; memset(vis, 0, sizeof(vis)); memset(s, 0, sizeof(s)); memset(dp, 0, sizeof(dp)); tot = 0; for(int i = 1; i &lt;= n; ++i) if(!vis[i]) &#123; ++tot; for(int j = i; !vis[j]; j = nxt[j]) &#123; ++s[tot]; vis[j] = 1; &#125; &#125; dp[0][0][0] = 1; for(int i = 1; i &lt;= tot; ++i) for(int A = a; ~A; --A) for(int B = b; ~B; --B) for(int C = c; ~C; --C) &#123; if(A &gt;= s[i]) dp[A][B][C] = (dp[A][B][C] + dp[A - s[i]][B][C]) % p; if(B &gt;= s[i]) dp[A][B][C] = (dp[A][B][C] + dp[A][B - s[i]][C]) % p; if(C &gt;= s[i]) dp[A][B][C] = (dp[A][B][C] + dp[A][B][C - s[i]]) % p; &#125; return dp[a][b][c];&#125;ll power(ll x, ll t) &#123; ll ret = 1; for(; t; t &gt;&gt;= 1, x = x * x % p) if(t &amp; 1) ret = ret * x % p; return ret; &#125;int main() &#123; scanf("%d%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;m, &amp;p); n = a + b + c; for(int i = 1; i &lt;= m; ++i) &#123; for(int j = 1; j &lt;= n; ++j) scanf("%d", &amp;nxt[j]); ans = (ans + Dp()) % p; &#125; for(int i = 1; i &lt;= n; ++i) nxt[i] = i; printf("%lld\n", (ans + Dp()) % p * power(m + 1, p - 2) % p); return 0;&#125; 2.$Pólya$定理poj2409Description:用m种颜色染n个珠子的项链，如果两种项链可以通过旋转以及翻转变成相同即算一种，问等价类数目。Solution:难点在于计算置换数目以及循环节数目，剩下套用$Pólya$定理即可。对于旋转共有$n$种，第$i$种旋转移动$i$步，循环节数量为$gcd(n,i)$。翻转分奇偶讨论，奇数只能以一个珠子为中心翻转，偶数可以以两个珠子或者空隙作为对称轴。总的置换数量有$2n$种。code:12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, m;int gcd(int a, int b) &#123; return !b ? a : gcd(b, a % b);&#125;ll power(ll x, ll t) &#123; ll ret = 1; for(; t; t &gt;&gt;= 1, x = x * x) if(t &amp; 1) ret = ret * x; return ret;&#125;int main() &#123; while(scanf("%d%d", &amp;m, &amp;n) &amp;&amp; (n || m)) &#123; ll ans = 0; for(int i = 0; i &lt; n; ++i) ans += power(m, gcd(i, n)); if(n &amp; 1) ans += n * power(m, n / 2 + 1); else ans += (n / 2) * (power(m, n / 2 + 1) + power(m, n / 2)); printf("%lld\n", ans / (2 * n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>置换群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 5212] 历史]]></title>
    <url>%2F2018%2F05%2F31%2Fbzoj-5212-%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[Description:给出一棵$n$个点的树以及每个点的$access$次数$a_i$，并给出$m$次修改某个点$access$次数，询问最多的轻重链切换次数。 Solution:对于每个点单独计算贡献。当一个点贡献一次轻重链切换次数，说明相邻两次$access$操作来自该点不同的儿子。设$sz_i$为点$i$子树中$a_i$的和,$mx_i$为所有儿子$sz$的最大值，对于当前点$i$贡献有三种情况:1.$2a_i&gt;sz_i$，答案为$2(sz_i-a_i)$2.$2mx_i&gt;sz_i$,答案为$2(sz_i-mx_i)$3.以上两种情况不存在，答案为$sz_i-1$ 考虑对于一个点的修改，一个点的贡献产生变化当且仅当这个点的重儿子发生改变，重儿子的定义为儿子$sz$超过当前点$sz$一半的点。那么用类似$LCT$的办法维护这个结构，重儿子连接产生一些重链，维护这些重链的形态以及$sz$，每次轻重链变化处修改答案即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 4e5 + 5;inline char get(void) &#123; static char buf[100000], *S = buf, *T = buf; if (S == T) &#123; T = (S = buf) + fread(buf, 1, 100000, stdin); if (S == T) return EOF; &#125; return *S++;&#125;inline int read() &#123; int x = 0; char c = get(); while(!isdigit(c)) c = get(); while(isdigit(c)) x = x * 10 + c - '0', c = get(); return x;&#125;struct node &#123; int f; int ch[2];&#125; t[maxn];int n, m;long long ans;int son[maxn];long long a[maxn], sz[maxn], f[maxn], tag[maxn];vector&lt;int&gt; G[maxn];inline bool isr(int x) &#123; return !t[x].f || (t[t[x].f].ch[0] != x &amp;&amp; t[t[x].f].ch[1] != x); &#125;inline int wh(int x) &#123; return x == t[t[x].f].ch[1]; &#125;inline void update(int x) &#123; ans -= f[x]; f[x] = sz[x] - 1; if(sz[son[x]] * 2 &gt; sz[x]) f[x] = 2LL * (sz[x] - sz[son[x]]); if(a[x] * 2 &gt; sz[x]) f[x] = 2LL * (sz[x] - a[x]); ans += f[x];&#125;void rotate(int x) &#123; int y = t[x].f, z = t[y].f, w = wh(x); t[x].f = z; if(!isr(y)) t[z].ch[wh(y)] = x; t[t[x].ch[w ^ 1]].f = y; t[y].ch[w] = t[x].ch[w ^ 1]; t[x].ch[w ^ 1] = y; t[y].f = x;&#125;inline void add(int x, long long v) &#123; if(x) &#123; tag[x] += v; sz[x] += v; &#125;&#125;inline void pushdown(int x) &#123; if(tag[x]) &#123; add(t[x].ch[0], tag[x]); add(t[x].ch[1], tag[x]); tag[x] = 0; &#125;&#125;inline void pd(int x) &#123; if(!isr(x)) pd(t[x].f); pushdown(x);&#125;inline void splay(int x) &#123; pd(x); for(; !isr(x); rotate(x)) if(!isr(t[x].f)) rotate(wh(t[x].f) == wh(x) ? t[x].f : x);&#125;inline int find(int x) &#123; while(t[x].ch[0]) &#123; pushdown(x); x = t[x].ch[0]; &#125; return x;&#125;void access(int x, int y) &#123; a[x] += y; for(int l = 0; x; l = x, x = t[x].f) &#123; splay(x); sz[x] += y; add(t[x].ch[0], y); if(son[x]) &#123; pd(son[x]); if(sz[son[x]] * 2 &lt;= sz[x]) son[x] = t[x].ch[1] = 0; &#125; int p = find(l); if(sz[p] * 2 &gt; sz[x]) son[x] = p, t[x].ch[1] = l; update(x); &#125;&#125;void dfs(int u, int f) &#123; sz[u] = a[u]; t[u].f = f; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(v == f) continue; dfs(v, u); sz[u] += sz[v]; &#125; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(v == f) continue; if(sz[v] * 2 &gt; sz[u]) &#123; son[u] = t[u].ch[1] = v; break; &#125; &#125; update(u);&#125;int main() &#123; n = read(); m = read(); for(int i = 1; i &lt;= n; ++i) a[i] = read(); for(int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); printf("%lld\n", ans); while(m--) &#123; int u = read(), v = read(); access(u, v); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 2876] 骑行川藏]]></title>
    <url>%2F2018%2F05%2F31%2Fbzoj-2876-%E9%AA%91%E8%A1%8C%E5%B7%9D%E8%97%8F%2F</url>
    <content type="text"><![CDATA[Description:给出$n$段路，每段路骑手的速度为$v_i$,那么骑手消耗的总能量为 \sum_{i=1}^{n}{k_i*(v_i-v'_i)*s_i}总时间为 \sum_{i=1}^{n}{\frac{s_i}{v_i}}现在希望骑手消耗总能量小于等于$E$的情况下走完$n$段路花费的时间最少。 Solution:拉格朗日乘数法是一种寻找变量受一个或多个条件所限制的多元函数的极值的方法。 设$f(v_1,v_2…v_n)$表示时间函数，$g(v_1,v_2…v_n)$表示能量函数，现在要求寻找多元函数$f(v_1,v_2…v_n)$的极值，并且要求满足限制$g(v_1,v_2…v_n)=E$。根据拉格朗日乘数法，设新的多元函数$F$ F(v_1,v_2...v_n)=f(v_1,v_2...v_n)+\lambda g(v_1,v_2...v_n)对所有$v_i$与$\lambda$做一阶偏导，得出方程组 \begin{cases} 2\lambda k_1v_1^2(v_1-v'_1)=1 \\ \vdots\\ 2\lambda k_nv_n^2(v_n-v'_n)=1\\ \sum_{i=1}^{n}{k_is_i(v_i-v'_i)^2}=E \end{cases}由于总能量与$v_i$成正比，所以$\lambda$与总能量成反比。二分$\lambda$,再二分$v_i$解方程即可。 Code:1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const double eps = 1e-12;int n;double E;double s[maxn], k[maxn], v[maxn], x[maxn];double calc(double lambda) &#123; double ret = 0; for(int i = 1; i &lt;= n; ++i) &#123; double l = 0, r = 1e9; while(r - l &gt; eps) &#123; double mid = (l + r) * 0.5; if(2 * lambda * k[i] * mid * mid * (mid - v[i]) &gt; 1) r = mid; else l = x[i] = mid; &#125; ret += k[i] * (x[i] - v[i]) * (x[i] - v[i]) * s[i]; &#125; return ret;&#125;int main() &#123; scanf("%d%lf", &amp;n, &amp;E); for(int i = 1; i &lt;= n; ++i) scanf("%lf%lf%lf", &amp;s[i], &amp;k[i], &amp;v[i]); double l = 0, r = 1e9; while(r - l &gt; eps) &#123; double mid = (l + r) * 0.5; if(calc(mid) &gt;= E) l = mid; else r = mid; &#125; double ans = 0; for(int i = 1; i &lt;= n; ++i) ans += s[i] / x[i]; printf("%.10f\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>拉格朗日乘数法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 3219] 巡游]]></title>
    <url>%2F2018%2F05%2F30%2Fbzoj-3219-%E5%B7%A1%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[Description:给出一棵$n$个点有边权的树，求节点数在$[L,R]$范围内中位数最大的路径。 Solution:长链剖分有两种应用，一个是$O(n)$统计每个点子树中可合并的以深度为下标的信息；另一个是经过一些预处理，单次$O(1)$在线查询一个点的$k$级祖先,这里使用了长链剖分的第一个应用。 二分答案，将边权大于等于当前答案的权值设为$1$，否则设为$-1$，判断当前答案是否合法等价于是否存在一条权值和大于等于$0$且节点数在$[L,R]$范围内的路径。 设当前统计点$u$子树内且经过$u$的路径的答案，通过长链剖分处理出子树中每种深度对应最长路径，用线段树保存，每次合并轻儿子在线段树中查询合法长度的路径最大值即可。 复杂度$O(nlog^2n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;inline char get(void) &#123; static char buf[100000], *S = buf, *T = buf; if (S == T) &#123; T = (S = buf) + fread(buf, 1, 100000, stdin); if (S == T) return EOF; &#125; return *S++;&#125;inline int read() &#123; int x = 0; char c = get(); while(!isdigit(c)) c = get(); while(isdigit(c)) x = x * 10 + c - '0', c = get(); return x;&#125;struct edge &#123; int nxt, to, w, c;&#125; e[maxn * 2];int n, L, R, dfs_clock, cnt = 1, ans;int h[maxn], son[maxn], mx[maxn * 4], dfn[maxn], Max[maxn], num[maxn], d[maxn], dep[maxn], tmp[maxn], a[maxn];void link(int u, int v, int w) &#123; e[++cnt].nxt = h[u]; h[u] = cnt; e[cnt].to = v; e[cnt].w = w;&#125;void build(int l, int r, int x) &#123; mx[x] = -1e9; if(l == r) &#123; num[l] = x; return; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, x &lt;&lt; 1); build(mid + 1, r, x &lt;&lt; 1 | 1);&#125;void update(int l, int r, int x, int p, int d) &#123; if(l == r) &#123; mx[x] = max(mx[x], d); return; &#125; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) update(l, mid, x &lt;&lt; 1, p, d); else update(mid + 1, r, x &lt;&lt; 1 | 1, p, d); mx[x] = max(mx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]);&#125;int query(int l, int r, int x, int a, int b) &#123; if(l &gt; b || r &lt; a) return -1e9; if(l &gt;= a &amp;&amp; r &lt;= b) return mx[x]; int mid = (l + r) &gt;&gt; 1; return max(query(l, mid, x &lt;&lt; 1, a, b), query(mid + 1, r, x &lt;&lt; 1 | 1, a, b));&#125;void dfs(int u, int f) &#123; Max[u] = dep[u]; for(int i = h[u]; i; i = e[i].nxt) if(e[i].to != f) &#123; dep[e[i].to] = dep[u] + 1; dfs(e[i].to, u); Max[u] = max(Max[u], Max[e[i].to]); if(Max[e[i].to] &gt; Max[son[u]]) son[u] = e[i].to; &#125; &#125;void dfs_1(int u, int f) &#123; dfn[u] = ++dfs_clock; if(son[u]) dfs_1(son[u], u); for(int i = h[u]; i; i = e[i].nxt) if(e[i].to != f &amp;&amp; e[i].to != son[u]) dfs_1(e[i].to, u);&#125;bool dfs_2(int u, int f) &#123; update(1, n, 1, dfn[u], d[u]); for(int i = h[u]; i; i = e[i].nxt) if(e[i].to == son[u]) &#123; d[son[u]] = d[u] + e[i].c; if(dfs_2(e[i].to, u)) return 1; &#125; for(int i = h[u]; i; i = e[i].nxt) if(e[i].to != f &amp;&amp; e[i].to != son[u]) &#123; d[e[i].to] = d[u] + e[i].c; if(dfs_2(e[i].to, u)) return 1; for(int j = 1; j &lt;= Max[e[i].to] - dep[u]; ++j) &#123; tmp[j] = mx[num[dfn[e[i].to] + j - 1]]; if(j &lt;= R) ans = max(ans, query(1, n, 1, max(1, dfn[u] + L - j), min(dfn[u] + R - j, dfn[u] + Max[u] - dep[u])) + tmp[j] - 2 * d[u]); &#125; for(int j = 1; j &lt;= Max[e[i].to] - dep[u]; ++j) update(1, n, 1, dfn[u] + j, tmp[j]); &#125; ans = max(ans, query(1, n, 1, dfn[u] + L, min(dfn[u] + R, dfn[u] + Max[u] - dep[u])) - d[u]); return ans &gt;= 0;&#125;int main() &#123; n = read(); L = read(); R = read(); for(int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(), w = read(); link(u, v, w); link(v, u, w); a[i] = w; &#125; dfs(1, 0); dfs_1(1, 0); int l = 0, r = n, Ans = -1; sort(a + 1, a + n); build(1, n, 1); while(r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; for(int i = 2; i &lt;= cnt; ++i) e[i].c = e[i].w &gt;= a[mid] ? 1 : -1; ans = -1e9; memset(mx, -0x3f3f, sizeof(mx)); if(dfs_2(1, 0)) &#123; l = mid; Ans = a[mid]; &#125; else r = mid; &#125; printf("%d\n", Ans); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 1115] 石子游戏Kam]]></title>
    <url>%2F2018%2F05%2F30%2Fbzoj-1115-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FKam%2F</url>
    <content type="text"><![CDATA[Description:有$n$堆石子，除了第一堆外，每堆石子个数都不少于前一堆的石子个数。两人轮流操作每次操作可以从一堆石子中移走任意多石子，但是要保证操作后仍然满足初始时的条件谁没有石子可移时输掉游戏。问先手是否必胜。 Solution:将序列差分，将差分数组看做新的游戏。发现游戏等价于一个人每一次可以将一个位置上的石子移至前一位置，如果所有石子移至$0$号位置游戏结束。这是经典的阶梯$NIM$游戏，等价于奇数项石子玩$NIM$游戏，求差分数组从第$n-1$项为开头向前的奇数项石子数异或和即可。 Code:12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int n;int a[maxn];int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;n); int last = 0, ans = 0; for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); for(int i = n; i &gt; 0; i -= 2) ans ^= a[i] - a[i - 1]; puts(ans ? "TAK" : "NIE"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 4241] 历史研究]]></title>
    <url>%2F2018%2F05%2F30%2Fbzoj-4241-%E5%8E%86%E5%8F%B2%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[Description:给出长度为$n$的序列，询问区间$[L,R]$权值乘以出现次数的最大值。 Solution:首先本题有一个比较暴力的利用莫队与线段树的方法，复杂度较高。上面的做法复杂度瓶颈在于无法做到删除时$O(1)$维护答案，于是引入了回滚莫队的做法。 先将询问按左端点所在块为第一关键字，右端点为第二关键字排序，如果左右端点位于同一块，暴力查询即可，单次复杂度$O(\sqrt{n})$。把左右端点不在同一块的询问按照左端点所在块分类，对于每一类询问，由于右端点递增，不断加入即可，由于左端点没有单调性，每次暴力加入后恢复原状即可做到只有加入。 总复杂度为$O(n\sqrt{n})$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int read() &#123; int x = 0; char c = getchar(); while(!isdigit(c)) c = getchar(); while(isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x;&#125;int n, m, l, r, pos;long long now, pre;int a[maxn], p[maxn];long long sum[maxn], num[maxn], ans[maxn];vector&lt;int&gt; v;struct data &#123; int l, r, b, id; bool friend operator &lt; (const data &amp;a, const data &amp;b) &#123; return a.b == b.b ? a.r &lt; b.r : a.b &lt; b.b; &#125;&#125; q[maxn];void add(int p) &#123; sum[p] += v[p]; now = max(now, sum[p]);&#125;void del(int p) &#123; sum[p] -= v[p];&#125;int main() &#123; n = read(); m = read(); int block = sqrt(n); for(int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); v.push_back(a[i]); &#125; sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); for(int i = 1; i &lt;= n; ++i) p[i] = lower_bound(v.begin(), v.end(), a[i]) - v.begin(); for(int i = 1; i &lt;= m; ++i) &#123; q[i].l = read(); q[i].r = read(); q[i].id = i; q[i].b = (q[i].l - 1) / block + 1; &#125; sort(q + 1, q + m + 1); for(int i = 1; i &lt;= m; ++i) &#123; if(q[i].b != q[i - 1].b) &#123; memset(sum, 0, sizeof(sum)); l = pos = q[i].b * block + 1; r = l - 1; pre = now = 0; &#125; if((q[i].l - 1) / block == (q[i].r - 1) / block) &#123; long long t = 0; for(int j = q[i].l; j &lt;= q[i].r; ++j) &#123; num[p[j]] += a[j]; t = max(t, num[p[j]]); &#125; for(int j = q[i].l; j &lt;= q[i].r; ++j) num[p[j]] -= a[j]; ans[q[i].id] = t; continue; &#125; while(r &lt; q[i].r) add(p[++r]); pre = now; while(l &gt; q[i].l) add(p[--l]); ans[q[i].id] = now; while(l &lt; pos) del(p[l++]); now = pre; &#125; for(int i = 1; i &lt;= m; ++i) printf("%lld\n", ans[i]); return 0; &#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 5354] 开房间]]></title>
    <url>%2F2018%2F05%2F26%2Fbzoj-5354-%E5%BC%80%E6%88%BF%E9%97%B4%2F</url>
    <content type="text"><![CDATA[Description:$n$个关卡，$m$个房间，两个人闯关。每个关卡一个人需要选择一个房间，花费为$t_{i,j}$,每个关卡结束后可以换房间，花费为房间编号差的绝对值乘以$k$，问最小花费。 Solution:考虑费用流模型，对于每个关卡的每个房间建立点，拆点计算费用。每个房间的点连向下一个关卡对应房间的点，相邻房间之间连费用为$k$的边表示计算换房间的花费。由于建出的模型为网格图，$spfa$无法快速解决，把$spfa$的队列换成堆即可。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cmath&gt;using namespace std;const int N = 200005, inf = 0x3f3f3f3f;#define id(i, j) (i - 1) * m + jstruct edge &#123; int nxt, to, f, w;&#125; e[2000005];int n, m, source, sink, cnt = 1, k;int h[N], d[N], Prev[N], pree[N], vis[N], t[305][305];char s[N];void link(int u, int v, int f, int c) &#123; e[++cnt].nxt = h[u]; h[u] = cnt; e[cnt].to = v; e[cnt].w = c; e[cnt].f = f;&#125;void insert(int u, int v, int f, int c) &#123; link(u, v, f, c); link(v, u, 0, -c);&#125;bool spfa() &#123; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; q; memset(d, 0x3f3f, sizeof(d)); d[source] = 0; q.push(make_pair(0, source)); while(!q.empty()) &#123; pair&lt;int, int&gt; o = q.top(); q.pop(); int u = o.second; vis[u] = 0; for(int i = h[u]; i; i = e[i].nxt) &#123; if(d[e[i].to] &gt; d[u] + e[i].w &amp;&amp; e[i].f) &#123; d[e[i].to] = d[u] + e[i].w; Prev[e[i].to] = u; pree[e[i].to] = i; if(!vis[e[i].to]) &#123; vis[e[i].to] = 1; q.push(make_pair(d[e[i].to], e[i].to)); &#125; &#125; &#125; &#125; return d[sink] != inf;&#125;int mcf() &#123; int ret = 0; while(spfa()) &#123; int now = sink, delta = inf; while(now != source) &#123; delta = min(delta, e[pree[now]].f); now = Prev[now]; &#125; now = sink; while(now != source) &#123; e[pree[now]].f -= delta; e[pree[now] ^ 1].f += delta; now = Prev[now]; &#125; ret += delta * d[sink]; &#125; return ret;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); sink = n * m * 2 + 1; int tmp = n * m * 2 + 2; insert(source, tmp, 2, 0); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) scanf("%d", &amp;t[i][j]); for(int i = 1; i &lt;= m; ++i) insert(tmp, id(1, i), 1, 0), insert(id(n, i) + n * m, sink, 1, 0); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) insert(id(i, j), id(i, j) + n * m, 1, t[i][j]); for(int i = 2; i &lt;= n; ++i) for(int j = 1; j &lt; m; ++j) insert(id(i, j), id(i, j + 1), inf, k), insert(id(i, j + 1), id(i, j), inf, k); for(int i = 1; i &lt; n; ++i) for(int j = 1; j &lt;= m; ++j) insert(id(i, j) + n * m, id(i + 1, j), 1, 0); printf("%d\n", mcf()); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 576D] Flights for Regular Customers]]></title>
    <url>%2F2018%2F05%2F26%2FCodeforces-576D-Flights-for-Regular-Customers%2F</url>
    <content type="text"><![CDATA[Description:给出一张$n$个点$m$条边有向图，每一条边有一个权值$w$,表示需要经过$w$条边才能经过这条边。问从$1$到$n$的最短步数。 Solution:设$dp[i][j]$表示从$1$出发走$j$步是否能到达$i$，暴力转移复杂度过高，不能通过此题。考虑通过矩阵快速幂优化转移过程。按边的权值排序，每次预先计算在之前的基础上走$w_i-w_{i-1}$步是否能到达$n$，如果能到达，那么暴力计算即可，否则继续转移，并在转移矩阵加入新的边。矩阵乘法通过$bitset$计算，复杂度$O(\frac{n^3}{32}logw)$。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 155;int n, m;struct matrix &#123; bitset&lt;maxn&gt; a[maxn]; matrix(int x) &#123; memset(a, 0, sizeof(a)); if(x == 1) for(int i = 1; i &lt;= n; ++i) a[i][i] = 1; &#125; matrix friend operator * (const matrix &amp;a, const matrix &amp;b) &#123; matrix ret(0); bitset&lt;maxn&gt; tmp[maxn]; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) tmp[j][i] = b.a[i][j]; for(int i = 1; i &lt;= n; ++i) if(a.a[i].any()) for(int j = 1; j &lt;= n; ++j) ret.a[i][j] = (a.a[i] &amp; tmp[j]).any(); return ret; &#125; matrix friend operator ^ (const matrix &amp;a, int t) &#123; matrix ret(1), x = a; for(; t; t &gt;&gt;= 1, x = x * x) if(t &amp; 1) ret = ret * x; return ret; &#125;&#125; now(0), G(0), nxt(0);struct edge &#123; int u, v, w; bool friend operator &lt; (const edge &amp;a, const edge &amp;b) &#123; return a.w &lt; b.w; &#125;&#125; e[maxn];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; ++i) scanf("%d%d%d", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); sort(e + 1, e + m + 1); G.a[n][n] = 1; now.a[1][1] = 1; for(int i = 1; i &lt;= m + 1; ++i) &#123; int t = i == m + 1 ? n : e[i].w - e[i - 1].w; nxt = now * (G ^ t); if(nxt.a[1][n]) &#123; for(int j = 0; j &lt;= n; ++j) &#123; if(now.a[1][n]) return printf("%d\n", j + e[i - 1].w), 0; now = now * G; &#125; &#125; else if(i == m + 1) &#123; return puts("Impossible"), 0; &#125; else &#123; now = nxt; G.a[e[i].u][e[i].v] = 1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>bitset</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 891E] Lust]]></title>
    <url>%2F2018%2F05%2F26%2FCodeforces-891E-Lust%2F</url>
    <content type="text"><![CDATA[Description:给出$n$个数$a_i$,$k$次操作，每个操作可以给$a_j$减少$1$，贡献为$\prod_{i!=j}{a_i}$,问期望贡献和。 Solution:设b_i表示a_i被操作了b_i次，考虑每次操作的贡献，得出最终答案为 \prod_{i=1}^{n}{a_i}-\prod_{i=1}^{n}{a_i-b_i}期望值等于贡献和除以方案数，那么 E=\prod_{i=1}^{n}{a_i}-\frac{k!}{n^k}\prod_{i=1}^{n}{\frac{a_i-b_i}{b_i!}}前一部分容易计算，考虑后一部分设$EGF$ F(x)=\sum_{i \geq 0}{\frac{a_i-i}{i!}}带入原式，有 \frac{k!}{n^k}\prod_{i=1}^{n}{F(x)}在第$k$项泰勒展开$F(x)$,有 \frac{k!}{n^k}\prod_{i=1}^{n}{e^x(a_i-x)}继续考虑后一半式子 e^{nx}\prod_{i=1}^{n}{a_i-x}设后半部分的$OGF$ G(x)=\sum_{i \geq 0}{c_ix^i}可以通过分治$NTT$在$O(nlog^2n)$的时间内求出再次泰勒展开，得出 \frac{k!}{n^k}\sum_{i=1}^{n}{c_i\frac{n^{(k-i)}}{(k-i)!}}最终答案 E=\prod_{i=1}^{n}{a_i}-\prod_{i=1}^{n}{c_i\frac{k^{\underline{i}}}{n^k}} Code:1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 5005, P = 1e9 + 7;int n, k;int a[N];ll f[N];ll power(ll x, ll t) &#123; ll ret = 1; for(; t; t &gt;&gt;= 1, x = x * x % P) &#123; if(t &amp; 1) &#123; ret = ret * x % P; &#125; &#125; return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); f[0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;a[i]); for(int j = i; j; --j) &#123; f[j] = ((f[j] * a[i] - f[j - 1]) % P + P) % P; &#125; f[0] = f[0] * a[i] % P; &#125; ll cur = 1, base = power(n, P - 2), ans = 0; for(int i = 0; i &lt;= n; ++i) &#123; ans = (ans + cur * f[i] % P) % P, cur = cur * base % P * (k - i) % P; &#125; printf("%lld\n", ((f[0] - ans) % P + P) % P); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>多项式 &amp; 生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 736D] Permutations]]></title>
    <url>%2F2018%2F05%2F24%2FCodeforces-736D-Permutations%2F</url>
    <content type="text"><![CDATA[Description:给出二分图邻接矩阵，保证二分图存在完美匹配且完美匹配个数为奇数个，每次询问删除一条边完美匹配数的奇偶。 Solution:二分图的完美匹配个数等于邻接矩阵的积和式，在模2意义下等于邻接矩阵的行列式。现在要求求出删掉一条边之后的奇偶性，相当于求出邻接矩阵的代数余子式，记为M。矩阵的行列式，逆矩阵，伴随矩阵有以下关系 A^{*}=|A|A^{-1}又有 A^{*}_{i,j}=M_{j,i}由于$|A|$模$2=1$，所以有 A^{*}=A^{-1}所以我们只要求出逆矩阵即可。 Code:123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2005;int n, m;bitset&lt;maxn&gt; a[maxn], b[maxn];int e[500005][2];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;e[i][0], &amp;e[i][1]); a[e[i][1]][e[i][0]] = 1; &#125; for(int i = 1; i &lt;= n; ++i) b[i][i] = 1; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = i; j &lt;= n; ++j) if(a[j][i]) &#123; swap(a[i], a[j]); swap(b[i], b[j]); break; &#125; if(!a[i][i]) continue; for(int j = 1; j &lt;= n; ++j) if(i != j &amp;&amp; a[j][i]) &#123; a[j] ^= a[i]; b[j] ^= b[i]; &#125; &#125; for(int i = 1; i &lt;= m; ++i) puts(b[e[i][0]][e[i][1]] ? "NO" : "YES"); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>bitset</tag>
        <tag>线性代数</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 5339] 教科书般的亵渎]]></title>
    <url>%2F2018%2F05%2F24%2Fbzoj-5339-%E6%95%99%E7%A7%91%E4%B9%A6%E8%88%AC%E7%9A%84%E4%BA%B5%E6%B8%8E%2F</url>
    <content type="text"><![CDATA[Description:求自然幂数和。 Solution:求 \sum_{i=1}^{n}{i^k}这是一个$k+1$次多项式，可以通过拉格朗日插值法在$O(k)$的时间复杂度内求出第n项的值。$k+1$次多项式需要$k+2$处点值确定多项式，预处理$1-k+2$的点值，拉格朗日插值法求第$n$项即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 105, P = 1e9 + 7;int m, k;ll n;ll fac[maxn], pre[maxn], suf[maxn], inv[maxn], a[maxn], sum[maxn];ll power(ll x, ll t) &#123; ll ret = 1; for(; t; t &gt;&gt;= 1, x = x * x % P) if(t &amp; 1) ret = ret * x % P; return ret;&#125;ll calc(ll *f, ll u, int n) &#123; pre[0] = suf[n + 2] = 1; for(int i = 1; i &lt;= n + 1; ++i) pre[i] = pre[i - 1] * (u - i + P) % P; for(int i = n + 1; i; --i) suf[i] = suf[i + 1] * (u - i + P) % P; ll ret = 0, tmp; for(int i = 1; i &lt;= n + 1; ++i) &#123; tmp = f[i] * pre[i - 1] % P * suf[i + 1] % P * inv[i - 1] % P * inv[n - i + 1] % P; if((n - i + 1) &amp; 1) tmp = P - tmp; ret = (ret + tmp) % P; &#125; return ret;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%lld%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; ++i) scanf("%lld", &amp;a[i]); a[m + 1] = n + 1; k = m + 1; sort(a + 1, a + m + 1); inv[0] = 1; fac[0] = 1; inv[1] = 1; for(int i = 1; i &lt;= k + 2; ++i) &#123; if(i != 1) inv[i] = (P - P / i) * inv[P % i] % P; fac[i] = fac[i - 1] * i % P; &#125; for(int i = 1; i &lt;= k + 2; ++i) inv[i] = inv[i] * inv[i - 1] % P; for(int i = 1; i &lt;= k + 2; ++i) sum[i] = (sum[i - 1] + power(i, k)) % P; ll ans = 0; for(int i = 1; i &lt;= k; ++i) &#123; for(int j = i; j &lt;= k; ++j) ans = (ans + calc(sum, a[j] - 1, k + 1) - calc(sum, a[j - 1], k + 1) + P) % P; ll t = a[i]; for(int j = i; j &lt;= k; ++j) a[j] -= t; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>拉格朗日插值法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[loj 2541] 猎人杀]]></title>
    <url>%2F2018%2F05%2F23%2Floj-2541-%E7%8C%8E%E4%BA%BA%E6%9D%80%2F</url>
    <content type="text"><![CDATA[Description:有$n$个猎人，每个猎人的仇恨值为$w_i$,一个猎人死亡时会开枪杀死一个猎人，这时猎人$k$被杀的概率为$\frac{w_k}{S}$,$S$为还活着的猎人的仇恨值之和。现在打响第一枪，问第一个猎人最后存活的概率。 Solution:考虑容斥，枚举在第一个人之后被杀的人，并乘上容斥系数。设$A$为所有人$w$值的和，$S$为选出人的集合$w$值的和，$P$为选出集合的大小，那么对于一个选出的人的集合，对答案的贡献为 (-1)^P\sum_{i=0}^{\infty}{[1-(\frac{S+w_1}{A})^i]\frac{w_1}{A}}=(-1)^P\sum_{i=0}^{\infty}{\frac{w_1}{S+w_1}}下面是关于该式正确性的论证把问题进行转化，每次一个猎人被射击，我们视作将其打上标记，并仍然存活。那么现在的要求变成在进行了$i$次射击后，第$1$个猎人被打上标记而其他猎人没有被打上标记，于是我们枚举射击次数，得到上面的式子。由于这是一个无穷的过程，所以现在的问题的所有情况和原问题的所有情况一一对应，所以是正确的。 剩下的问题是求出所有$S$集合以及容斥系数的和，利用分治$NTT$优化背包$dp$即可。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5, P = 998244353;int n, v, N, len;int tmp[maxn], a[maxn], b[maxn], w[maxn], sum[maxn];int power(int x, int t) &#123; int ret = 1; for(; t; t &gt;&gt;= 1, x = 1LL * x * x % P) if(t &amp; 1) ret = 1LL * ret * x % P; return ret;&#125;void NTT(int *a, int f) &#123; for(int i = 0; i &lt; N; ++i) &#123; int t = 0; for(int j = 0; j &lt; len; ++j) if(i &gt;&gt; j &amp; 1) t |= 1 &lt;&lt; (len - j - 1); if(i &lt; t) swap(a[i], a[t]); &#125; for(int l = 2; l &lt;= N; l &lt;&lt;= 1) &#123; int m = l &gt;&gt; 1, w = power(3, f == 1 ? (P - 1) / l : P - 1 - (P - 1) / l); for(int i = 0; i &lt; N; i += l) &#123; int t = 1; for(int k = 0; k &lt; m; ++k, t = 1LL * t * w % P) &#123; int x = a[i + k], y = 1LL * t * a[i + m + k] % P; a[i + k] = (x + y) % P; a[i + m + k] = (x - y + P) % P; &#125; &#125; &#125; if(f == -1) &#123; int inv = power(N, P - 2); for(int i = 0; i &lt; N; ++i) a[i] = 1LL * a[i] * inv % P; &#125;&#125;void cdq(int *tmp, int l, int r) &#123; if(l == r) &#123; tmp[w[l]] = P - 1; return; &#125; int mid = l + r &gt;&gt; 1, p1 = sum[mid] - sum[l - 1], p2 = sum[r] - sum[mid]; cdq(tmp, l, mid); cdq(tmp + p1, mid + 1, r); for(int i = 1; i &lt;= p1; ++i) a[i] = tmp[i]; for(int i = 1; i &lt;= p2; ++i) b[i] = tmp[i + p1]; for(N = 1, len = 0; N &lt;= p1 + p2; N &lt;&lt;= 1) ++len; a[0] = b[0] = 1; for(int i = p1 + 1; i &lt; N; ++i) a[i] = 0; for(int i = p2 + 1; i &lt; N; ++i) b[i] = 0; NTT(a, 1); NTT(b, 1); for(int i = 0; i &lt; N; ++i) a[i] = 1LL * a[i] * b[i] % P; NTT(a, -1); for(int i = 1; i &lt;= p1 + p2; ++i) tmp[i] = a[i];&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;v); --n; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;w[i]); sum[i] = sum[i - 1] + w[i]; &#125; int ans = 1; cdq(tmp, 1, n); for(int i = 1; i &lt;= sum[n]; ++i) ans = (ans + 1LL * tmp[i] * power(v + i, P - 2) % P * v % P) % P; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>多项式 &amp; 生成函数</tag>
        <tag>容斥原理</tag>
        <tag>概率与期望</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 3930] 选数]]></title>
    <url>%2F2018%2F05%2F23%2Fbzoj-3930-%E9%80%89%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Description:给出区间$[L,R]$,从中选出$n$个可重复的数，要求这些数的最大公约数为$k$，求选数的方案数。 Solution:设$f(d)$表示选出的数最大公约数为$d$的方案数，$F(d)$表示选出的数最大公约数为$d$的倍数的方案数，根据莫比乌斯反演有 f(d)=\sum_{D|d}{F(\frac{D}{d})*\mu(d)}枚举最大公约数k的倍数次，转化为 \begin{eqnarray}f(n) &=&\sum_{i=1}^{[\frac{R}{k}]}{\mu(i)F([\frac{R}{ki}])}\\ &=&\sum_{i=1}^{[\frac{R}{k}]}{\mu(i)([\frac{R}{i}]-[\frac{L-1}{i}])^n}\\ \end{eqnarray}于是分块求和，问题转化为求$\mu$的前缀和，杜教筛即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e7 + 5, P = 1e9 + 7;int n, k, L, R, m;long long ans;int mu[maxn], mark[maxn], p[maxn];map&lt;int, long long&gt; mp;long long power(long long x, long long t) &#123; long long ret = 1; for(; t; t &gt;&gt;= 1, x = x * x % P) if(t &amp; 1) ret = ret * x % P; return ret;&#125;void Shaker() &#123; mu[1] = 1; for(int i = 2; i &lt; maxn; ++i) &#123; if(!mark[i]) &#123; p[++p[0]] = i; mu[i] = -1; &#125; for(int j = 1; j &lt;= p[0] &amp;&amp; i * p[j] &lt; maxn; ++j) &#123; mark[i * p[j]] = 1; if(i % p[j] == 0) break; mu[i * p[j]] = -mu[i]; &#125; &#125; for(int i = 1; i &lt; maxn; ++i) mu[i] += mu[i - 1];&#125;long long get_mu(int n) &#123; if(n &lt; maxn) return mu[n]; if(mp.find(n) != mp.end()) return mp[n]; long long ret = 1; for(int i = 2, j; i &lt;= n; i = j + 1) &#123; j = n / (n / i); ret -= (j - i + 1) * get_mu(n / i); &#125; return mp[n] = ret;&#125;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;k, &amp;L, &amp;R); Shaker(); L = (L - 1) / k; R = R / k; for(int i = 1, j; i &lt;= R; i = j + 1) &#123; j = min(R / (R / i), L / i ? L / (L / i) : 1000000000); ans = (ans + (get_mu(j) - get_mu(i - 1) + P) % P * power(R / i - L / i, n) % P) % P; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 1382] Mars Map]]></title>
    <url>%2F2018%2F05%2F22%2Fbzoj-1382-Mars-Map%2F</url>
    <content type="text"><![CDATA[Description:求矩形面积并。 Solution:将矩形拆成左右边界，按$y$坐标排序后进行扫描线。动态开点线段树维护$x$坐标轴被覆盖的长度，每次遇到新的线段统计答案。 Code:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;struct data &#123; int l, r, y, f; data() &#123;&#125; data(int _l, int _r, int _y, int _f) : l(_l), r(_r), y(_y), f(_f) &#123;&#125; bool friend operator &lt; (const data &amp;a, const data &amp;b) &#123; return a.y &lt; b.y; &#125;&#125; a[maxn * 2];int n, rt, m, cnt;long long ans;int sum[maxn * 30], tag[maxn * 30], lc[maxn * 30], rc[maxn * 30];void update(int l, int r, int &amp;x, int a, int b, int d) &#123; if(l &gt; b || r &lt; a) return; if(!x) x = ++cnt; if(l &gt;= a &amp;&amp; r &lt;= b) &#123; tag[x] += d; if(tag[x] == 0) sum[x] = sum[lc[x]] + sum[rc[x]]; else sum[x] = r - l + 1; return; &#125; int mid = (l + r) &gt;&gt; 1; update(l, mid, lc[x], a, b, d); update(mid + 1, r, rc[x], a, b, d); if(!tag[x]) sum[x] = sum[lc[x]] + sum[rc[x]];&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; int x1, x2, y1, y2; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); a[i] = data(x1, x2, y1, 1); a[i + n] = data(x1, x2, y2, -1); m = max(m, x2); &#125; sort(a + 1, a + 2 * n + 1); for(int i = 1; i &lt;= 2 * n; ++i) &#123; ans += 1LL * (a[i].y - a[i - 1].y) * sum[1]; update(1, m, rt, a[i].l + 1, a[i].r, a[i].f); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 5317] 部落战争]]></title>
    <url>%2F2018%2F05%2F22%2Fbzoj-5317-%E9%83%A8%E8%90%BD%E6%88%98%E4%BA%89%2F</url>
    <content type="text"><![CDATA[Description:给出两个点集,再每次给出一个向量，问第一个点集沿该向量平移是否与第二个点集有交。 Solution:设第一个点集为$A$，第二个点集为$B$，向量为$\vec{v}$，那么即相当于$A-B=\vec{v}$。 对两个点集求凸包，求出两个凸包的闵可夫斯基和，本质上是求$\vec{v}$是否位于求出闵可夫斯基和的凸包内。二分判断点是否在凸包内，复杂度$O(nlogn)$。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;struct P &#123; double x, y; P() &#123;&#125; P(double _x, double _y) : x(_x), y(_y) &#123;&#125; friend bool operator &lt; (const P &amp;a, const P &amp;b) &#123; return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x; &#125; friend P operator + (const P &amp;a, const P &amp;b) &#123; return P(a.x + b.x, a.y + b.y); &#125; friend P operator - (const P &amp;a, const P &amp;b) &#123; return P(a.x - b.x, a.y - b.y); &#125; friend P operator * (const P &amp;a, double b) &#123; return P(a.x * b, a.y * b); &#125; friend double operator * (const P &amp;a, const P &amp;b) &#123; return a.x * b.y - a.y * b.x; &#125;&#125; a[maxn], b[maxn], c[maxn], d[maxn], p[maxn], tmp[maxn];int n, m, ans, tot, q;int st[maxn * 2];bool in(P t, P *p, int top) &#123; int l = 1, r = top, pos = 1; if((t - p[1]) * (p[2] - p[1]) &gt; 0 || (t - p[1]) * (p[tot] - p[1]) &lt; 0) return 0; while(r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; if((p[mid] - p[1]) * (t - p[1]) &gt;= 0) l = pos = mid; else r = mid; &#125; return (p[pos % top + 1] - p[pos]) * (t - p[pos]) &gt;= 0;&#125;int graham(P *p, int n) &#123; int top = 0; sort(p + 1, p + n + 1); for(int i = 1; i &lt;= n; ++i) tmp[i] = p[i]; for(int i = 1; i &lt;= n; ++i) &#123; while(top &gt; 1 &amp;&amp; (p[i] - p[st[top - 1]]) * (p[st[top]] - p[st[top - 1]]) &gt;= 0) --top; st[++top] = i; &#125; int lim = top; for(int i = n - 1; i; --i) &#123; while(top &gt; lim &amp;&amp; (p[i] - p[st[top - 1]]) * (p[st[top]] - p[st[top - 1]]) &gt;= 0) --top; st[++top] = i; &#125; for(int i = 1; i &lt; top; ++i) p[i] = tmp[st[i]]; return top - 1;&#125;void Minkowski() &#123; p[tot = 1] = a[1] + b[1]; for(int i = 1, j = 1; i &lt;= n || j &lt;= m;) &#123; P t1 = a[(i - 1) % n + 1] + b[j % m + 1], t2 = a[i % n + 1] + b[(j - 1) % m + 1]; if((t1 - p[tot]) * (t2 - p[tot]) &gt;= 0) p[++tot] = t1, ++j; else p[++tot] = t2, ++i; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; ++i) scanf("%lf%lf", &amp;a[i].x, &amp;a[i].y); for(int i = 1; i &lt;= m; ++i) scanf("%lf%lf", &amp;b[i].x, &amp;b[i].y); for(int i = 1; i &lt;= m; ++i) b[i].x = -b[i].x, b[i].y = -b[i].y; n = graham(a, n); m = graham(b, m); Minkowski(); while(q--) &#123; double x, y; scanf("%lf%lf", &amp;x, &amp;y); printf("%d\n", in(P(x, y), p, tot)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 840C] On the Bench]]></title>
    <url>%2F2018%2F05%2F21%2FCodeforces-840C-On-the-Bench%2F</url>
    <content type="text"><![CDATA[Description:求满足相邻两数乘积不为完全平方数的排列个数。 Solution:首先转化限制，将所有数的完全平方因子全部去除，那么相邻两个数乘积为完全平方数的条件即为两个数相等。 将转化后相同的数分成一组按组进行$dp$。设$dp[i][j]$表示前$i$组有$j$个相等的数相邻,$sum$为之前所有数之间的空隙个数。考虑转移,枚举当前的数分成$k+1$组，再考虑插入的位置，可插入的位置有两种情况，分别是位于两个相等或不相等的数中间，枚举插入相等空隙数的组数$p$，得出转移 dp[i][j+sz[i]-k-p-1]=dp[i-1][j]*C_{k}^{p}*C_{sz[i]-1}^{k}*C_{sum+2-j}^{k+p-1} Code:123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 305, P = 1e9 + 7;int n, sum, m;int a[maxn], sz[maxn], c[maxn][maxn], fac[maxn], dp[maxn][maxn];int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; ++i) for(int j = 2; j * j &lt;= a[i]; ++j) while(a[i] % (j * j) == 0) a[i] /= j * j; sort(a + 1, a + n + 1); for(int i = 1; i &lt;= n; ++i) if(a[i] != a[i - 1]) sz[++m] = 1; else ++sz[m]; c[0][0] = 1; fac[0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; c[i][0] = 1; fac[i] = 1LL * fac[i - 1] * i % P; for(int j = 1; j &lt;= i; ++j) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % P; &#125; dp[1][sz[1] - 1] = 1; sum = -1; for(int i = 2; i &lt;= m; ++i) &#123; sum += sz[i - 1]; for(int j = 0; j &lt;= sum; ++j) &#123; for(int k = 0; k &lt; sz[i]; ++k) &#123; for(int p = 0; p &lt;= min(j, k + 1); ++p) &#123; dp[i][j + sz[i] - 1 - k - p] = (dp[i][j + sz[i] - 1 - k - p] + 1LL * dp[i - 1][j] * c[sz[i] - 1][k] % P * c[j][p] % P * c[sum + 2 - j][k + 1 - p] % P) % P; &#125; &#125; &#125; &#125; int ans = dp[m][0]; for(int i = 1; i &lt;= m; ++i) ans = 1LL * ans * fac[sz[i]] % P; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[loj 2340] 州区划分]]></title>
    <url>%2F2018%2F05%2F20%2Floj-2340-%E5%B7%9E%E5%8C%BA%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[Description:给出$n$个城市和$m$条双向道路，一个合法的州的定义是该州不存在欧拉回路。现在要求统计对于所有合法方案满意度的和。定义一个方案的满意度为方案中每个州的满意度的乘积，每个州的满意度为第$i$个州的人口在前$i$个州的人口中所占比例的$p$次幂。 Solution:定义$dp[i][S]$表示集合为$S$的城市划分为$i$个州的满意度和，g[S]表示当前S集合合法的情况下的满意度，考虑转移 dp[i][S] = dp[i-1][S-S0]*g[S0]复杂度为$O(3^nn)$，无法通过此题。 考虑利用$FMT$优化，由于$FMT$是或和，不能直接做。改变状态，设$dp[i][S]$表示当前一共所有州的城市数量和，且这些州城市的并集为$S$，这些州的城市可以相交;$g[i][S]$表示城市集合$S$，一共有$i$个州。先用$FMT$把所有变量转化为点值，然后进行$dp$即可。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = (1 &lt;&lt; 21) + 5, P = 998244353;struct edge &#123; int u, v; edge() &#123;&#125; edge(int _u, int _v) : u(_u), v(_v) &#123;&#125;&#125; e[405];int n, m, p;int w[22], d[22], f[22][maxn], g[22][maxn], inv[maxn], fa[22], s[maxn];int find(int x) &#123; return x == fa[x] ? x : fa[x] = find(fa[x]);&#125;int power(int x, int t) &#123; int ret = 1; for(; t; t &gt;&gt;= 1, x = 1LL * x * x % P) if(t &amp; 1) ret = 1LL * ret * x % P; return ret;&#125; void FMT(int *a, int f) &#123; int L = 1 &lt;&lt; n; for(int i = 1; i &lt; L; i &lt;&lt;= 1) for(int j = 0; j &lt; L; ++j) if(i &amp; j) &#123; a[j] += a[j ^ i] * f; if(a[j] &lt; 0) a[j] += P; else if(a[j] &gt;= P) a[j] -= P; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;p); for(int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); --u; --v; e[i] = edge(u, v); &#125; for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;w[i]); for(int S = 1; S &lt; 1 &lt;&lt; n; ++S) &#123; int sum = 0, cnt = 0; for(int i = 0; i &lt; n; ++i) d[i] = 0, fa[i] = i; for(int i = 0; i &lt; n; ++i) &#123; if(S &gt;&gt; i &amp; 1) &#123; sum += w[i]; ++cnt; &#125; &#125; int bit = cnt; s[S] = sum; inv[S] = power(power(s[S], P - 2), p); for(int i = 1; i &lt;= m; ++i) if((S &gt;&gt; e[i].u &amp; 1) &amp;&amp; (S &gt;&gt; e[i].v &amp; 1))&#123; int u = find(e[i].u), v = find(e[i].v); ++d[e[i].u]; ++d[e[i].v]; if(u != v) &#123; fa[u] = v; --cnt; &#125; &#125; bool f = 0; for(int i = 0; i &lt; n; ++i) if(S &gt;&gt; i &amp; 1) f |= d[i] &amp; 1; if(f || cnt &gt; 1) g[bit][S] = power(s[S], p); &#125; f[0][0] = 1; FMT(f[0], 1); for(int i = 1; i &lt;= n; ++i) FMT(g[i], 1); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= i; ++j) for(int S = 0; S &lt; 1 &lt;&lt; n; ++S) f[i][S] = (f[i][S] + 1LL * f[i - j][S] * g[j][S] % P) % P; FMT(f[i], -1); for(int S = 0; S &lt; 1 &lt;&lt; n; ++S) f[i][S] = 1LL * f[i][S] * inv[S] % P; if(i &lt; n) FMT(f[i], 1); &#125; printf("%d\n", f[n][(1 &lt;&lt; n) - 1]); return 0;&#125;]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>多项式 &amp; 生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 5341] 暴力写挂]]></title>
    <url>%2F2018%2F05%2F18%2Fbzoj-5341-%E6%9A%B4%E5%8A%9B%E5%86%99%E6%8C%82%2F</url>
    <content type="text"><![CDATA[Descripiton:给出两棵树，最大化$dep(x)+dep(y)-dep(lca(x,y))-dep(lca’(x,y))$ Solution:化简式子，得出 \frac{dis(x,y)+dis'(x,y)+dep(x)+dep(y)-dep'(x)-dep'(y)}{2}点分治第二棵树，把第一棵树建出虚树，把第二棵树上的信息附在第一棵树上，在虚树上进行$dp$,两个点可以进行转移当且仅当两个点在第二棵树上跨越重心。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 366670;namespace IO &#123; const int Maxlen = maxn * 50; char buf[Maxlen], *C = buf; int Len; inline void read_in() &#123; Len = fread(C, 1, Maxlen, stdin); buf[Len] = '\0'; &#125; inline void fread(int &amp;x) &#123; x = 0; int f = 1; while (*C &lt; '0' || '9' &lt; *C) &#123; if(*C == '-') f = -1; ++C; &#125; while ('0' &lt;= *C &amp;&amp; *C &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + *C - '0', ++C; x *= f; &#125; inline void fread(long long &amp;x) &#123; x = 0; long long f = 1; while (*C &lt; '0' || '9' &lt; *C) &#123; if(*C == '-') f = -1; ++C; &#125; while ('0' &lt;= *C &amp;&amp; *C &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + *C - '0', ++C; x *= f; &#125; inline void read(int &amp;x) &#123; x = 0; int f = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0'; c = getchar(); &#125; x *= f; &#125; inline void read(long long &amp;x) &#123; x = 0; long long f = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 1ll) + (x &lt;&lt; 3ll) + c - '0'; c = getchar(); &#125; x *= f; &#125; &#125; using namespace IO;int n, m, rt;ll ans = -1e18;int seq[maxn * 2], bel[maxn], vis[maxn];vector&lt;int&gt; G[maxn];ll len[maxn];struct Tree &#123; struct edge &#123; int nxt, to; ll w; &#125; e[maxn * 2]; struct data &#123; int type; ll v; data(int _type = 0, ll _v = -1e15) : type(_type), v(_v) &#123;&#125; bool friend operator &lt; (const data &amp;a, const data &amp;b) &#123; return a.v &gt; b.v; &#125; &#125; val[maxn][2]; int cnt, dfs_clock; int h[maxn], dep[maxn], fa[maxn][21], sz[maxn], dfn[maxn], st[maxn], End[maxn], mir[maxn], bl[maxn]; ll dis[maxn]; void link(int u, int v, ll w) &#123; e[++cnt].nxt = h[u]; h[u] = cnt; e[cnt].to = v; e[cnt].w = w; &#125; void dfs(int u, int f) &#123; dfn[u] = ++dfs_clock; mir[dfn[u]] = u; for(int i = h[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == f) continue; dis[v] = dis[u] + e[i].w; dep[v] = dep[u] + 1; fa[v][0] = u; dfs(v, u); &#125; End[u] = dfs_clock; &#125; void dfs(int u, int f, int b) &#123; sz[u] = 1; seq[++m] = u; bel[u] = b; for(int i = h[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(vis[v] || v == f) continue; len[v] = len[u] + e[i].w; dfs(v, u, b); sz[u] += sz[v]; &#125; &#125; void build() &#123; dfs(1, 0); for(int j = 1; j &lt;= 20; ++j) for(int i = 1; i &lt;= n; ++i) fa[i][j] = fa[fa[i][j - 1]][j - 1]; &#125; int lca(int u, int v) &#123; if(dep[u] &lt; dep[v]) swap(u, v); int d = dep[u] - dep[v]; for(int i = 20; ~i; --i) if(d &gt;&gt; i &amp; 1) u = fa[u][i]; if(u == v) return u; for(int i = 20; ~i; --i) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i]; return fa[u][0]; &#125; void getroot(int u, int f, int s) &#123; bool t = 1; sz[u] = 1; for(int i = h[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == f || vis[v]) continue; getroot(v, u, s); sz[u] += sz[v]; t &amp;= sz[v] &lt;= s &gt;&gt; 1; &#125; t &amp;= sz[u] &gt;= s &gt;&gt; 1; if(t) rt = u; &#125; void dfs(int u) &#123; val[u][0] = val[u][1] = data(); if(bel[u]) val[u][0] = data(bel[u], len[u] + dis[u]); for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; dfs(v); for(int a = 0; a &lt; 2; ++a) if(val[u][a].type) for(int b = 0; b &lt; 2; ++b) if(val[v][b].type &amp;&amp; val[u][a].type != val[v][b].type) ans = max(ans, val[u][a].v + val[v][b].v - (dis[u] &lt;&lt; 1)); data tmp[4]; tmp[0] = val[u][0]; tmp[1] = val[u][1]; tmp[2] = val[v][0]; tmp[3] = val[v][1]; sort(tmp, tmp + 4); val[u][0] = tmp[0]; val[u][1] = data(); for(int a = 1; a &lt; 4; ++a) if(tmp[a].type &amp;&amp; tmp[a].type != tmp[0].type) &#123; val[u][1] = tmp[a]; break; &#125; &#125; &#125; void solve() &#123; vector&lt;int&gt; v; for(int i = 1; i &lt;= m; ++i) v.push_back(dfn[seq[i]]); sort(v.begin(), v.end()); m = 0; for(int i = 0; i &lt; v.size(); ++i) seq[++m] = mir[v[i]]; for(int i = m; i &gt; 1; --i) seq[++m] = lca(seq[i], seq[i - 1]); v.clear(); for(int i = 1; i &lt;= m; ++i) v.push_back(dfn[seq[i]]); sort(v.begin(), v.end()); m = 0; v.erase(unique(v.begin(), v.end()), v.end()); m = 0; for(int i = 0; i &lt; v.size(); ++i) seq[++m] = mir[v[i]]; int top = 0; for(int i = 1; i &lt;= m; ++i) &#123; for(; top &amp;&amp; !(dfn[st[top]] &lt;= dfn[seq[i]] &amp;&amp; End[st[top]] &gt;= End[seq[i]]);) --top; if(top) G[st[top]].push_back(seq[i]); st[++top] = seq[i]; &#125; dfs(seq[1]); for(int i = 1; i &lt;= m; ++i) &#123; G[seq[i]].clear(); bel[seq[i]] = 0; &#125; &#125;&#125; A, B;void solve(int u, int s) &#123; rt = 0; B.getroot(u, 0, s); vis[u = rt] = 1; seq[m = 1] = u; bel[u] = u; len[u] = 0; for(int i = B.h[u]; i; i = B.e[i].nxt) &#123; int v = B.e[i].to; if(!vis[v]) &#123; len[v] = B.e[i].w; B.dfs(v, u, v); &#125; &#125; for(int i = 1; i &lt;= m; ++i) len[seq[i]] += A.dis[seq[i]] - B.dis[seq[i]]; A.solve(); for(int i = B.h[u]; i; i = B.e[i].nxt) &#123; int v = B.e[i].to; if(!vis[v]) solve(v, B.sz[v]); &#125;&#125;int main() &#123; read_in(); fread(n); for(int i = 1; i &lt; n; ++i) &#123; int u, v; ll w; fread(u); fread(v); fread(w); A.link(u, v, w); A.link(v, u, w); &#125; for(int i = 1; i &lt; n; ++i) &#123; int u, v; ll w; fread(u); fread(v); fread(w); B.link(u, v, w); B.link(v, u, w); &#125; A.build(); B.build(); solve(1, n); for(int i = 1; i &lt;= n; ++i) ans = max(ans, A.dis[i] - B.dis[i] &lt;&lt; 1); printf("%lld\n", ans &gt;&gt; 1); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>虚树</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 5334] 数学计算]]></title>
    <url>%2F2018%2F05%2F17%2Fbzoj-5334-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[Description:给出一个初始为$1$的数$x$，执行两种操作:1.乘上一个数并取模2.撤销某次乘法输出操作后的数$x$ Solution:线段树维护操作，如果是撤销则把对应位置赋为$1$。 Code:12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int m, P;int t[400005];void update(int l, int r, int x, int p, int d) &#123; if(l == r) &#123; t[x] = d; return; &#125; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) update(l, mid, x &lt;&lt; 1, p, d); else update(mid + 1, r, x &lt;&lt; 1 | 1, p, d); t[x] = 1LL * t[x &lt;&lt; 1] * t[x &lt;&lt; 1 | 1] % P;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;m, &amp;P); fill(t + 1, t + 4 * m + 1, 1); for(int i = 1; i &lt;= m; ++i) &#123; int opt, x; scanf("%d%d", &amp;opt, &amp;x); if(opt == 1) &#123; update(1, m, 1, i, x); &#125; else &#123; update(1, m, 1, x, 1); &#125; printf("%d\n", t[1]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 3684] 大朋友和多叉树]]></title>
    <url>%2F2018%2F05%2F17%2Fbzoj-3684-%E5%A4%A7%E6%9C%8B%E5%8F%8B%E5%92%8C%E5%A4%9A%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Description:求满足以下条件无标号子节点有顺序多叉树:1.给出$S$集合，满足除叶节点之外的点的度数属于$S$2.每一个叶节点点权为$1$，且非叶节点点权为儿子点权值和，要求根节点点权为$m$ Solution:树的$OGF$ F(x)=\sum_{n \geq 0}{t_ix^i}由于孩子有序且无标号，得出 F(x)=x+x^0\sum_{k \in S}{F(x)^k}移项得出 x=F(x)-\sum_{k \in S}{F(x)^k}设 G(x)=x-\sum_{k \in S}{x^k}那么有 x=G(F(x))根据拉格朗日反演，有 [x^n]F(x)=[x^{n-1}]\frac{1}{n}(\frac{x}{G(x)})^n现在我们需要多项式求逆以及多项式快速幂 多项式快速幂可以以$O(nlogn)$的时间复杂度求出 F(x)^k=exp(ln(F(x)^k))=exp(kln(F(x)))前提要求多项式常数项为$1$ 总复杂度$O(nlogn)$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5, P = 950009857;int n, N = 1, m, len;int da[maxn], ia[maxn], a[maxn], b[maxn], inv[maxn], t[maxn];int power(int x, int t) &#123; int ret = 1; for(; t; t &gt;&gt;= 1, x = 1LL * x * x % P) if(t &amp; 1) ret = 1LL * ret * x % P; return ret;&#125;namespace ntt &#123; void dft(int *a, int N, int f) &#123; int len = 0; while(1 &lt;&lt; len &lt; N) ++len; for(int i = 0; i &lt; N; ++i) &#123; int t = 0; for(int j = 0; j &lt; len; ++j) if(i &gt;&gt; j &amp; 1) t |= 1 &lt;&lt; (len - j - 1); if(i &lt; t) swap(a[i], a[t]); &#125; for(int l = 2; l &lt;= N; l &lt;&lt;= 1) &#123; int m = l &gt;&gt; 1, w = power(7, f == 1 ? (P - 1) / l : P - 1 - (P - 1) / l); for(int i = 0; i &lt; N; i += l) &#123; int t = 1; for(int k = 0; k &lt; m; ++k, t = 1LL * t * w % P) &#123; int x = a[i + k], y = 1LL * t * a[i + m + k] % P; a[i + k] = (x + y) % P; a[i + m + k] = (x - y + P) % P; &#125; &#125; &#125; if(f == -1) &#123; int inv = power(N, P - 2); for(int i = 0; i &lt; N; ++i) a[i] = 1LL * a[i] * inv % P; &#125; &#125; void inverse(int *a, int *b, int l) &#123; static int t[maxn]; if(l == 1) &#123; b[0] = power(a[0], P - 2); return; &#125; inverse(a, b, l &gt;&gt; 1); int N = l &lt;&lt; 1; for(int i = 0; i &lt; l; ++i) t[i] = a[i]; for(int i = l; i &lt; N; ++i) t[i] = 0; dft(b, N, 1); dft(t, N, 1); for(int i = 0; i &lt; N; ++i) b[i] = 1LL * b[i] * (2 - 1LL * b[i] * t[i] % P + P) % P; dft(b, N, -1); for(int i = l; i &lt; N; ++i) b[i] = 0; &#125; void ln(int *a, int *b, int l) &#123; static int da[maxn], ia[maxn]; int N = l &lt;&lt; 1; for(int i = 0; i &lt; N; ++i) ia[i] = da[i] = 0; for(int i = 0; i &lt; l - 1; ++i) da[i] = 1LL * (i + 1) * a[i + 1] % P; inverse(a, ia, l); dft(ia, N, 1); dft(da, N, 1); for(int i = 0; i &lt; N; ++i) b[i] = 1LL * da[i] * ia[i] % P; dft(b, N, -1); for(int i = l - 1; i; --i) b[i] = 1LL * b[i - 1] * inv[i] % P; b[0] = 0; for(int i = l; i &lt; N; ++i) b[i] = 0; &#125; void exp(int *a, int *b, int l) &#123; static int t[maxn]; if(l == 1) &#123; b[0] = 1; return; &#125; exp(a, b, l &gt;&gt; 1); int N = l &lt;&lt; 1; for(int i = 0; i &lt; N; ++i) t[i] = 0; ln(b, t, l); for(int i = 0; i &lt; l; ++i) t[i] = (a[i] - t[i] + P) % P; t[0] = (t[0] + 1) % P; dft(b, N, 1); dft(t, N, 1); for(int i = 0; i &lt; N; ++i) b[i] = 1LL * b[i] * t[i] % P; dft(b, N, -1); for(int i = l; i &lt; N; ++i) b[i] = 0; &#125; void power(int *a, int n, int l) &#123; static int t[maxn]; int N = l &lt;&lt; 1; memset(t, 0, sizeof(t)); ln(a, t, l); for(int i = 0; i &lt; l; ++i) t[i] = 1LL * t[i] * n % P; for(int i = 0; i &lt; N; ++i) a[i] = 0; exp(t, a, l); &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); a[0] = 1; for(int i = 1; i &lt;= m; ++i) &#123; int x; scanf("%d", &amp;x); a[x - 1] = P - 1; &#125; while(N &lt;= n) N &lt;&lt;= 1, ++len; inv[0] = inv[1] = 1; for(int i = 2; i &lt;= N; ++i) inv[i] = 1LL * (P - P / i) * inv[P % i] % P; ntt::inverse(a, b, N); ntt::power(b, n, N); printf("%d\n", 1LL * b[n - 1] * inv[n] % P); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>多项式 &amp; 生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 3456] 城市规划]]></title>
    <url>%2F2018%2F05%2F16%2Fbzoj-3456-%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[Description:求$n$个点有标号无向连通图个数。 Solution:考虑无向图的$EGF$ G(x) = \sum_{n \geq 0}{2^{C_{n}^{2}}*\frac{x^n}{n!}}每一项的系数表示无标号的无向图个数再考虑和无向连通图的关系设无向连通图的$EGF$为 F(x) = \sum_{n \geq 0}{C_n*\frac{x^n}{n!}}根据组合关系，得出 G(x) = e^{F(x)}那么推得 F(x)=ln(G(x))多项式求$ln$即可，复杂度$O(nlogn)$ 如何思考出关于$EGF$的做法？因为无向联通图是无向图的划分，自然联想到$EGF$。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5, P = 1004535809;int n, N = 1, len;int fac[maxn], facinv[maxn], inv[maxn], a[maxn], ia[maxn], da[maxn], t[maxn];int power(int x, int t) &#123; int ret = 1; for(; t; t &gt;&gt;= 1, x = 1LL * x * x % P) if(t &amp; 1) ret = 1LL * ret * x % P; return ret;&#125;namespace ntt &#123; void dft(int *a, int f) &#123; for(int i = 0; i &lt; N; ++i) &#123; int t = 0; for(int j = 0; j &lt; len; ++j) if(i &gt;&gt; j &amp; 1) t |= 1 &lt;&lt; (len - j - 1); if(i &lt; t) swap(a[i], a[t]); &#125; for(int l = 2; l &lt;= N; l &lt;&lt;= 1) &#123; int m = l &gt;&gt; 1, w = power(3, f == 1 ? (P - 1) / l : P - 1 - (P - 1) / l); for(int i = 0; i &lt; N; i += l) &#123; int t = 1; for(int k = 0; k &lt; m; ++k, t = 1LL * t * w % P) &#123; int x = a[i + k], y = 1LL * t * a[i + m + k] % P; a[i + k] = (x + y) % P; a[i + m + k] = (x - y + P) % P; &#125; &#125; &#125; if(f == -1) &#123; int inv = power(N, P - 2); for(int i = 0; i &lt; N; ++i) a[i] = 1LL * a[i] * inv % P; &#125; &#125; void inverse(int *a, int *b, int l) &#123; if(l == 1) &#123; b[0] = power(a[0], P - 2); return; &#125; inverse(a, b, l &gt;&gt; 1); N = 1; len = 0; while(N &lt;= l) N &lt;&lt;= 1, ++len; for(int i = 0; i &lt; l; ++i) t[i] = a[i]; for(int i = l; i &lt; N; ++i) t[i] = 0; dft(t, 1); dft(b, 1); for(int i = 0; i &lt; N; ++i) b[i] = 1LL * b[i] * (2 - 1LL * t[i] * b[i] % P + P) % P; dft(b, -1); for(int i = l; i &lt; N; ++i) b[i] = 0; &#125; void ln(int *a) &#123; for(int i = 0; i &lt; N - 1; ++i) da[i] = 1LL * a[i + 1] * (i + 1) % P; inverse(a, ia, N); dft(da, 1); dft(ia, 1); for(int i = 0; i &lt; N; ++i) a[i] = 1LL * ia[i] * da[i] % P; dft(a, -1); for(int i = N - 1; i; --i) a[i] = 1LL * a[i - 1] * inv[i] % P; a[0] = 0; &#125;&#125;int main() &#123; scanf("%d", &amp;n); while(N &lt;= n) N &lt;&lt;= 1, ++len; fac[0] = inv[0] = facinv[0] = facinv[1] = inv[1] = 1; for(int i = 1; i &lt;= n; ++i) &#123; if(i != 1) &#123; inv[i] = 1LL * (P - P / i) * inv[P % i] % P; facinv[i] = 1LL * facinv[i - 1] * inv[i] % P; &#125; fac[i] = 1LL * fac[i - 1] * i % P; &#125; a[0] = 1; for(int i = 1; i &lt;= n; ++i) a[i] = 1LL * power(2, 1LL * i * (i - 1) / 2 % (P - 1)) * facinv[i] % P; ntt::ln(a); printf("%d\n", 1LL * a[n] * fac[n] % P); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>多项式 &amp; 生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[loj 2478] 林克卡特树]]></title>
    <url>%2F2018%2F05%2F15%2Floj-2478-%E6%9E%97%E5%85%8B%E5%8D%A1%E7%89%B9%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Description:从树上选出$k+1$条不相交的链，要求权值和最大。 Solution:运用了$wqs$二分的做法。考虑这样一类最优化问题，要求选出恰好$k$个物品。由于$k$的限制比较强，如果去掉k的限制一般是一个简单的问题。通过二分一个附加值，每选出一个物品将这个物品的价值减去附加值再进行计算，最后加上$k$个附加值，这样可以解决问题。 这道题首先二分附加值$x$，进行树形$dp$，第一关键字是全职，第二关键字是链的数量，设计状态$dp[u][0/1/2]$表示点$u$连出去的度数为$0/1/2$,且完成子树结算的值。$val[u]$表示尚未完成结算的值，也就是点$u$可以继续延伸。$dp$转移枚举选或不选即可。 感性理解正确性，如果二分的附加值较小，那么选出的链肯定会较多，否则较少，这样就满足了关于链的数量的单调性，自然可以保证选出满足$k$的最优解。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;struct edge &#123; int nxt, to, w;&#125; e[maxn * 2];struct data &#123; long long sum; int cnt; data() &#123;&#125; data(long long _sum, int _cnt) : sum(_sum), cnt(_cnt) &#123;&#125; bool friend operator &lt; (const data &amp;a, const data &amp;b) &#123; return a.sum == b.sum ? a.cnt &gt; b.cnt : a.sum &lt; b.sum; &#125; data friend operator + (const data &amp;a, const data &amp;b) &#123; return data(a.sum + b.sum, a.cnt + b.cnt); &#125;&#125; dp[maxn][3], val[maxn];int n, cnt = 1, k;long long l = -1e12, r = 1e12, mid, ans = -1e12;int h[maxn];void link(int u, int v, int w) &#123; e[++cnt].nxt = h[u]; h[u] = cnt; e[cnt].to = v; e[cnt].w = w;&#125;void dfs(int u, int f) &#123; int cnt = 0; long long sum = 0; dp[u][1] = dp[u][2] = data(-1e12, 0); for(int i = h[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v != f) &#123; dfs(v, u); val[v] = max(max(dp[v][0], dp[v][1]), dp[v][2]); val[v].sum -= mid; ++val[v].cnt; val[v] = max(val[v], dp[v][0]); sum += val[v].sum; cnt += val[v].cnt; &#125; &#125; dp[u][0] = data(sum, cnt); for(int i = h[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v != f) &#123; long long x = e[i].w - val[v].sum; dp[u][2] = max(dp[u][2], dp[u][1] + data(dp[v][0].sum + x, -val[v].cnt + dp[v][0].cnt)); dp[u][2] = max(dp[u][2], dp[u][1] + data(dp[v][1].sum + x, -val[v].cnt + dp[v][1].cnt)); dp[u][1] = max(dp[u][1], dp[u][0] + data(dp[v][0].sum + x, -val[v].cnt + dp[v][0].cnt)); dp[u][1] = max(dp[u][1], dp[u][0] + data(dp[v][1].sum + x, -val[v].cnt + dp[v][1].cnt)); &#125; &#125;&#125; int main() &#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt; n; ++i) &#123; int u, v, c; scanf("%d%d%d", &amp;u, &amp;v, &amp;c); link(u, v, c); link(v, u, c); &#125; while(r - l &gt; 1) &#123; mid = (l + r) / 2; dfs(1, 0); data t = max(max(dp[1][0], dp[1][1]), dp[1][2]); t.sum -= mid; ++t.cnt; t = max(t, dp[1][0]); if(t.cnt == k + 1) &#123; ans = t.sum + mid * (k + 1); break; &#125; if(t.cnt &lt;= k) &#123; r = mid; ans = t.sum + 1LL * (k + 1) * mid; &#125; else &#123; l = mid; &#125; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用说明]]></title>
    <url>%2F2018%2F05%2F15%2FHexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[一些使用hexo的tips Hexo的搭建1.安装node.js1sudo apt-get install nodejs 2.安装git1sudo apt-get install git 3.安装hexo1npm install -g hexo-cli 4.初始化123hexo init &lt;dir&gt;cd &lt;dir&gt;npm install 本地博客已建好12hexo ghexo s 访问http://localhost:4000/本地预览 5.Gitbub部署注册Github创建一个新的repositories，名字叫xxx.github.io改变_config.yml中对应内容1234deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master 执行123hexo cleanhexo ghexo d 访问xxx.github.io即可。 Hexo支持mathjax1.安装mathjaxhttps://blog.csdn.net/u014630987/article/details/78670258最后一步具体位置为/node_modules/kramed/lib/rules/inline.js 2.markdown数学公式https://blog.csdn.net/thither_shore/article/details/52260742]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTSC & APIO 2018 游记]]></title>
    <url>%2F2018%2F05%2F07%2FCTSC-APIO-2018-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言考的不好，失误较多,记录一下比赛的历程。 CTSC-DAY0宾馆入住，由于是小床房，室友和家长去了外边住。晚上做了一道题早早地睡了，希望明天好好发挥，至少得拿个牌。 CTSC-DAY1先看了看三道题，第一道题叙述较长，不是很清楚难度;第二道题和冬令营的考题十分相似，可是我并没有学习正确做法，而且既然出题人敢再次出这个idea，肯定是有备而来。第三道题大概不可做，暴力分不是很多。仔细研究了一下第一题，发现70分是一个简单的背包，100分神似bzoj2287,是一个删除物品的背包，可是我已经忘记了那题的正确做法。如果用NTT或分治做感觉并不能多得分。于是写了70分做法，由于一个细节写错了，过了大样例已经用时2.5小时。第二题的暴力分不是很明确。O(n^2)的做法可以用st表做，但是n=8666的数据范围似乎并不能跑过，于是删掉了写完待调的st表，改成了暴力求lca。其他的部分分说不定可做，也可以尝试乱搞，可是由于认为第一题可做，于是时间全部砸给了第一题。剩下的时间写完了第三题25分暴力，然后思考第一题直至结束，仍然没有想出来dp解决的方法。 到了查分的时间，得分是70+30+10=110。这是一个很低的分数，其他同学大多比我高上一些，t3前面的暴力wa了，听了讲课又得知第二题O(n^2)可以通过45分，第一题的正解是可逆背包。如果考试的时候拿到了后面的暴力，那么分数也不算低了，这样做的难度也并不大。70+45+25=140算是一个不错的分数。第一题思维僵化，由于原题并不能用可逆的方法做，自己虽然想到了却放弃了这个做法，看来比赛的时候不能过分依赖原题，也要开创新的想法。这个分大概是铜牌了，110实在是有点低。 CTSC-DAY2答辩日，打打游戏做做题听听讲度过了一天。感觉最有用的论文是关于生成函数的，大多数论文都是命题报告。 CTSC-DAY3抱着翻盘的想法进入考场，如果考的高一些银牌也是能达到的。看完了三道题，觉得第一题最可做，于是思考了一下在40分钟过了这道题。这有点打乱我的节奏了，做题的速度也缓慢了下来。又花了不少的时间看懂后面两道题。第二题的暴力似乎比较困难，第三题是提答，并没有做过，先去研究第三题。花了很长时间研究第三题，由于不熟悉题答的做法，先开始对ans文件进行了操作，然后又思考了如何写出通解，最后才发现每个点都有不同的特性，第一个点可以爆搜，后面的点可以网络流，中间的点似乎可以乱搞。这时还剩2个小时，由于第二题还没有写，于是去尝试第二题的40分暴力，不停地写写写，直到结束。 100+0+6 这是今天的得分。”狗牌?”我想道。其他同学都做出了t1,t3也拿了不少的分。可以说今天做出了第一题的人分数都比我高。玩游戏吧，没什么好想的。剩下的时间都在游戏中度过。 APIO-DAY0在宾馆中度过，打打游戏做做题，想想APIO能不能弥补CTSC的铁牌。 APIO-DAY1旁边坐着集训队大爷，气场强大，让我感受到了小说中来自高手的压迫。看了看三道题，第三道题是一个求割点，难点应该在于讨论。对于自己的代码能力没有很强的自信，转战其他题。旁边的同学已经写上了第一题，于是转去思考第一题的做法。想了很长很长时间仍然没有头绪，想到了二分，却没有很好的办法解决查询可行的方法。时间过得很快，只剩下两个半小时了，自己却一分没得。这样会重复省选时的悲剧，赶紧写了第二三题的暴力，获得了7+31分。一会又写完了第一题的12分，这时机器开始卡了，反馈很慢，只能等待结果返回。第二题y=0的部分大概是一个标记永久化线段树，写写写调调调，由于中间不断看结果花了很长时间。最后交上去直到结束也没有反馈。 和同学去食堂吃饭，除了zjc其他人比我还低，大家都不太会做今天的题，如果剩下的12分拿到了说不定能有Ag。 回去看了看结果，没有过，还是50分，Cu预定。 APIO-DAY2在寝室里待了一天，颓颓颓。晚上zty告诉我我拿了两个铜。CTSC能拿铜牌真是令人感动，但是仍然被所有人吊打。 疏散日回家。 总结CTSC挂在策略，APIO挂在自己弱，APIO只拿了GXZ的0.18。希望NOI能考好点，至少不要像CTSC这样难看。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 3516] 国王饮水记加强版]]></title>
    <url>%2F2018%2F05%2F06%2Fbzoj-3516-%E5%9B%BD%E7%8E%8B%E9%A5%AE%E6%B0%B4%E8%AE%B0%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[Description:求$\sum_{i=1}^{n}{m^ii^m}$ Solution:设$f(i)=\sum_{k=1}^{n}{k^ii^m}$运用扰动法得出 \begin{eqnarray}(m-1)f(i) &=&\sum_{k=1}^{n}{k^i*m^{k+1}}-\sum_{k=1}^{n}{k^i*m^k}\\ &=&n^im^{n+1}+\sum_{k=1}^{n}{m^k\sum_{j=0}^{i-1}{C(i,j)(-1)^{i-j}k^j}}\\ &=&n^i+m^{n+1}+\sum_{j=0}^{i-1}{C(i,j)(-1)^{i-j}f(j)} \end{eqnarray}$O(m^2)$递推即可。 Code:12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1005, P = 1e9 + 7;int n, m, inv;ll c[maxn][maxn], f[maxn];ll power(ll x, ll t) &#123; ll ret = 1; for(; t; t &gt;&gt;= 1, x = x * x % P) &#123; if(t &amp; 1) &#123; ret = ret * x % P; &#125; &#125; return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); if(m == 1) &#123; printf("%lld\n", 1LL * n * (n + 1) / 2 % P); return 0; &#125; c[0][0] = 1; for(int i = 1; i &lt;= m; ++i) &#123; c[i][0] = 1; for(int j = 1; j &lt;= m; ++j) &#123; c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % P; &#125; &#125; inv = power(m - 1, P - 2); f[0] = (((power(m, n + 1) - 1) * inv - 1) % P + P) % P; for(int i = 1; i &lt;= m; ++i) &#123; f[i] = power(n, i) * power(m, n + 1) % P; for(int j = 0; j &lt; i; ++j) &#123; f[i] = ((f[i] + c[i][j] * ((i - j) &amp; 1 ? -1 : 1) * f[j] % P) % P + P) % P; &#125; f[i] = f[i] * power(m - 1, P - 2) % P; &#125; printf("%lld\n", f[m]); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>数学技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 286E] Ladies' Shop]]></title>
    <url>%2F2018%2F05%2F06%2FCodeforces-286E-Ladies-Shop%2F</url>
    <content type="text"><![CDATA[Description:给出$n$个数$a_i$,求从中选出最少的数$b_i$使得这些数做完全背包能表示的$\leq m$的数的集合等于$a_i$数的集合。 Solution:很明显选出所有的$a_i$是满足条件的，如果$a_i$能表示的数的集合在$\leq m$的情况下不等于a的集合，就是无解的。考虑构造解,根据题目条件，我们只要判断a中哪些数能够由其他数构造出来，只要把这些能够被构造出来的数删掉即是最小解。由于现在保证有解，所以满足能被构造出来的数$a_k$满足$a_k=a_i+a_j$,那么构造生成函数即可判断每个数是否可以被构造。无解的情况为一个数$x$满足$x=a_i+a_j$且没出现在a中。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;const double pi = acos(-1), eps = 1e-5;int read() &#123; int x = 0, f = 1; char c = getchar(); while(!isdigit(c)) &#123; if(c == '-') f = -1; c = getchar(); &#125; while(isdigit(c)) &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x * f;&#125;int n, m, N, len;int A[maxn];vector&lt;int&gt; ans;struct cp &#123; double x, y; cp() &#123;&#125; cp(double _x, double _y) : x(_x), y(_y) &#123;&#125; cp friend operator + (const cp &amp;a, const cp &amp;b) &#123; return cp(a.x + b.x, a.y + b.y); &#125; cp friend operator - (const cp &amp;a, const cp &amp;b) &#123; return cp(a.x - b.x, a.y - b.y); &#125; cp friend operator * (const cp &amp;a, const cp &amp;b) &#123; return cp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;&#125; a[maxn * 4];void FFT(cp *a, int f) &#123; for(int i = 0; i &lt; N; ++i) &#123; int t = 0; for(int j = 0; j &lt; len; ++j) &#123; if(i &gt;&gt; j &amp; 1) &#123; t |= 1 &lt;&lt; (len - j - 1); &#125; &#125; if(i &lt; t) &#123; swap(a[i], a[t]); &#125; &#125; for(int l = 2; l &lt;= N; l &lt;&lt;= 1) &#123; int m = l &gt;&gt; 1; cp w = cp(cos(pi / m), f * sin(pi / m)); for(int i = 0; i &lt; N; i += l) &#123; cp t = cp(1, 0); for(int k = 0; k &lt; m; ++k, t = t * w) &#123; cp x = a[i + k], y = t * a[i + m + k]; a[i + k] = x + y; a[i + m + k] = x - y; &#125; &#125; &#125; if(f == -1) &#123; for(int i = 0; i &lt; N; ++i) &#123; a[i].x /= N; &#125; &#125;&#125;int main() &#123; n = read(); m = read(); for(int i = 1; i &lt;= n; ++i) &#123; int x = read(); A[x] = 1; a[x].x = 1; &#125; for(N = 1; N &lt;= 2 * m; N &lt;&lt;= 1) &#123; ++len; &#125; FFT(a, 1); for(int i = 0; i &lt; N; ++i) &#123; a[i] = a[i] * a[i]; &#125; FFT(a, -1); for(int i = 1; i &lt;= m; ++i) &#123; if(!A[i] &amp;&amp; fabs(a[i].x) &gt; eps) &#123; puts("NO"); return 0; &#125; if(A[i] &amp;&amp; fabs(a[i].x) &lt; eps) &#123; ans.push_back(i); &#125; &#125; puts("YES"); printf("%d\n", ans.size()); for(int i = 0; i &lt; ans.size(); ++i) &#123; printf("%d ", ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>多项式 &amp; 生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 4650] 优秀的拆分]]></title>
    <url>%2F2018%2F05%2F06%2Fbzoj-4650-%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86%2F</url>
    <content type="text"><![CDATA[Description:求形如$AABB$子串个数。 Solution:对于每个位置$i$求出$pre[i]$和$suf[i]$,分别表示以$i$为结尾和开头形如$AA$的子串个数。那么答案就是 \sum_{i=1}^{n-1}{pre[i]*suf[i+1]}如何求形如$AA$的子串有一种经典做法，枚举$A$的长度$l$，每隔$l$插一个关键点。那么每个长为$2l$的$AA$形串都会跨过两个关键点。考虑每个$A$串的活动范围，求出相邻两个关键点向左右两边分别能拓展多远，这个可以用后缀数组求$lcp$解决。然后确定$AA$串可以出现的范围，就可以计算$pre$和$suf$。差分数组统计$suf$和$pre$即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int n, m;long long ans;int a[N], pre[N], suf[N], Log[N];char s[N];struct Suffix_Array &#123; int a[N], b[N], rank[N], lcp[N], sa[N], mn[N][20], rnk[N]; void ini() &#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); memset(rank, 0, sizeof(rank)); memset(lcp, 0, sizeof(lcp)); memset(sa, 0, sizeof(sa)); memset(mn, 0, sizeof(mn)); memset(rnk, 0, sizeof(rnk)); &#125; void radix(int *s, int *a, int *b, int n, int m) &#123; int count[N]; memset(count, 0, sizeof(count)); for(int i = 1; i &lt;= n; ++i) ++count[s[a[i]]]; for(int i = 1; i &lt;= m; ++i) count[i] += count[i - 1]; for(int i = n; i; --i) b[count[s[a[i]]]--] = a[i]; &#125; void Sa(int *s) &#123; for(int i = 1; i &lt;= n; ++i) rank[i] = i; radix(s, rank, sa, n, max(n, 26)); rank[sa[1]] = 1; for(int i = 2; i &lt;= n; ++i) rank[sa[i]] = rank[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]); for(int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; for(int i = 1; i &lt;= n; ++i) &#123; a[i] = rank[i]; b[i] = i + k &lt;= n ? rank[i + k] : 0; sa[i] = i; &#125; radix(b, sa, rank, n, max(n, 26)); radix(a, rank, sa, n, max(n, 26)); rank[sa[1]] = 1; for(int i = 2; i &lt;= n; ++i) rank[sa[i]] = rank[sa[i - 1]] + (a[sa[i]] != a[sa[i - 1]] || b[sa[i]] != b[sa[i - 1]]); &#125; int h = 0; for(int i = 1; i &lt;= n; ++i) rank[sa[i]] = i; for(int i = 1; i &lt;= n; ++i) &#123; int j = sa[rank[i] - 1]; if(rank[i] &lt;= 1) continue; if(h &gt; 0) --h; for(; i + h &lt;= n &amp;&amp; j + h &lt;= n; ++h) if(s[i + h] != s[j + h]) break; lcp[rank[i]] = h; &#125; for(int i = 1; i &lt;= n; ++i) mn[i][0] = lcp[i]; for(int j = 1; j &lt;= 19; ++j) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; mn[i][j] = min(mn[i][j - 1], mn[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; int query(int l, int r) &#123; l = rank[l]; r = rank[r]; if(l &gt; r) swap(l, r); ++l; int x = Log[r - l + 1]; return min(mn[l][x], mn[r - (1 &lt;&lt; x) + 1][x]); &#125;&#125; A, B;int main() &#123; int T; scanf("%d", &amp;T); for(int i = 2; i &lt;= 30000; ++i) &#123; Log[i] = Log[i &gt;&gt; 1] + 1; &#125; while(T--) &#123; memset(pre, 0, sizeof(pre)); memset(suf, 0, sizeof(suf)); scanf("%s", s + 1); n = strlen(s + 1); for(int i = 1; i &lt;= n; ++i) &#123; a[i] = s[i] - 'a'; &#125; A.ini(); B.ini(); A.Sa(a); reverse(s + 1, s + n + 1); for(int i = 1; i &lt;= n; ++i) &#123; a[i] = s[i] - 'a'; &#125; B.Sa(a); for(int l = 1; l * 2 &lt;= n; ++l) &#123; for(int i = l; i + l &lt;= n; i += l) &#123; int x = min(A.query(i, i + l), l), y = min(B.query(n - i + 1, n - i - l + 1), l), r = i + l, len = x + y - l; if(x + y &gt; l) &#123; ++suf[i - y + 1]; --suf[i - y + 1 + len]; ++pre[r + x - len]; --pre[r + x]; &#125; &#125; &#125; for(int i = 1; i &lt;= n; ++i) &#123; pre[i] += pre[i - 1]; suf[i] += suf[i - 1]; &#125; long long ans = 0; for(int i = 1; i &lt; n; ++i) &#123; ans += 1LL * pre[i] * suf[i + 1]; &#125; printf("%lld\n", ans); &#125; return 0; &#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 4585] 烟火表演]]></title>
    <url>%2F2018%2F05%2F05%2Fbzoj-4585-%E7%83%9F%E7%81%AB%E8%A1%A8%E6%BC%94%2F</url>
    <content type="text"><![CDATA[Descrpiton:一棵有边权的树，求使所有叶子节点到根距离相同的最小修改代价。 Solution:设$f(x)$表示叶子到根距离为x的花费。那么有 f(x)=\sum{|x-w|}所以得出$f(x)$是一个下凸的分段一次函数。考虑对于$f(x)$有两种操作1.加入到父亲的边2.合并儿子的凸壳由于我们只关心拐点的值，所以第二种情况直接暴力合并即可。第一种情况即是$f(x) -&gt; f(x + w)$设x在区间$[L,R]$取到最小值，那么我们可以得出新的函数$F(x) = f(x) + w$ $(x \leq L)$$F(x) = f(L) + w - (x - L)$ $(L \leq x \leq L + w)$$F(x) = f(L)$ $(L + w \leq x \leq R + w)$$F(x) = f(L) + (x - R) - w$ $(R + w \leq x)$发现事实上是将原来平移，再加入斜率为$-1,0,1$的三段函数。由于只需要拐点，于是我们用可并堆维护拐点之间的大小关系即可,最后答案即是边权和减去斜率为负的拐点。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 6e5 + 5;int n, m, tot;long long ans;int lc[maxn], rc[maxn], d[maxn], len[maxn], rt[maxn], fa[maxn], deg[maxn];long long v[maxn];int merge(int x, int y) &#123; if(!x) &#123; return y; &#125; if(!y) &#123; return x; &#125; if(v[x] &lt; v[y]) &#123; swap(x, y); &#125; rc[x] = merge(rc[x], y); if(d[rc[x]] &gt; d[lc[x]]) &#123; swap(lc[x], rc[x]); &#125; if(!rc[x]) &#123; d[x] = 0; &#125; else &#123; d[x] = d[rc[x]] + 1; &#125; return x;&#125;int pop(int u) &#123; return merge(lc[u], rc[u]);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 2; i &lt;= n + m; ++i) &#123; scanf("%d%d", &amp;fa[i], &amp;len[i]); ans += len[i]; ++deg[fa[i]]; &#125; for(int i = n + m; i &gt; 1; --i) &#123; long long l = 0, r = 0; if(i &lt;= n) &#123; while(--deg[i]) &#123; rt[i] = pop(rt[i]); &#125; r = v[rt[i]]; rt[i] = pop(rt[i]); l = v[rt[i]]; rt[i] = pop(rt[i]); &#125; v[++tot] = l + len[i]; v[++tot] = r + len[i]; rt[i] = merge(rt[i], merge(tot, tot - 1)); rt[fa[i]] = merge(rt[i], rt[fa[i]]); &#125; while(deg[1]--) &#123; rt[1] = pop(rt[1]); &#125; while(rt[1]) &#123; ans -= v[rt[1]]; rt[1] = pop(rt[1]); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>凸包</tag>
        <tag>可并堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 452E] Three strings]]></title>
    <url>%2F2018%2F05%2F05%2FCodeforces-452E-Three-strings%2F</url>
    <content type="text"><![CDATA[Description:给出三个字符串$s_1,s_2,s_3$,对于每个长度$L$,问有多少对三元组$(i_1,i_2,i_3)$满足三个串中分别以这三个位置为开头长度为$L$的字符串相同。 Solution:多串问题用广义后缀自动机解决，建出三个串的广义后缀自动机，分别统计三个串的$Right$集合，对于每个状态统计状态对应长度对答案的贡献，差分数组统计答案即可。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 6e5 + 5, P = 1e9 + 7;int n, len = P;int r[maxn][3], c[maxn], a[maxn], ans[maxn];char s[maxn];vector&lt;int&gt; G[maxn * 2];namespace SAM &#123; struct node &#123; int val, par; int ch[26]; &#125; t[maxn * 2]; int last = 1, root = 1, sz = 1; int nw(int x) &#123; t[++sz].val = x; return sz; &#125; void extend(int c, int tt) &#123; int p = last, np = nw(t[p].val + 1); while(p &amp;&amp; !t[p].ch[c]) t[p].ch[c] = np, p = t[p].par; if(!p) t[np].par = root; else &#123; int q = t[p].ch[c]; if(t[q].val == t[p].val + 1) t[np].par = q; else &#123; int nq = nw(t[p].val + 1); memcpy(t[nq].ch, t[q].ch, sizeof(t[q].ch)); t[nq].par = t[q].par; t[q].par = t[np].par = nq; while(p &amp;&amp; t[p].ch[c] == q) t[p].ch[c] = nq, p = t[p].par; &#125; &#125; last = np; r[last][tt] = 1; &#125;&#125; using namespace SAM;void dfs(int u) &#123; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; dfs(v); for(int j = 0; j &lt; 3; ++j) &#123; r[u][j] += r[v][j]; &#125; &#125;&#125;int main() &#123; for(int i = 0; i &lt; 3; ++i) &#123; scanf("%s", s + 1); n = strlen(s + 1); len = min(len, n); last = root; for(int j = 1; j &lt;= n; ++j) &#123; extend(s[j] - 'a', i); &#125; &#125; for(int i = 1; i &lt;= sz; ++i) &#123; G[t[i].par].push_back(i); &#125; dfs(root); for(int i = 1; i &lt;= sz; ++i) &#123; int L = t[t[i].par].val + 1, R = t[i].val, d = 1LL * r[i][0] * r[i][1] % P * r[i][2] % P; ans[L] = (ans[L] + d) % P; ans[R + 1] = (ans[R + 1] - d + P) % P; &#125; for(int i = 1; i &lt;= len; ++i) &#123; ans[i] = (ans[i] + ans[i - 1]) % P; printf("%d ", ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[学习笔记] dsu on tree]]></title>
    <url>%2F2018%2F05%2F04%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-dsu-on-tree%2F</url>
    <content type="text"><![CDATA[简介一种树上启发式合并，用于离线不带修改统计子树信息，要求每个点能$O(1)$修改，复杂度$O(nlogn)$。 算法过程先将树轻重链剖分，先递归做完轻儿子，然后做重儿子，顺便统计重儿子的信息。然后统计轻儿子子树信息得到答案，如果当前点不是父亲的重链清空信息。 复杂度分析我们发现每个点被统计当这个点不位于另一个点重儿子的子树中。根据轻重链剖分的性质，我们知道一个点到根最多经过$logn$条轻边，说明每个点最多被统计$logn$次，又修改复杂度为$O(1)$,所以总复杂度为$O(nlogn)$。 例题Codeforces 600E Lomsat gelralDescription:询问每颗子树中出现次数最多的颜色们编号和。code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int n, m, Max;vector&lt;int&gt; G[maxn];int sz[maxn], son[maxn], a[maxn], cou[maxn], big[maxn];long long ans[maxn];pair&lt;int, long long&gt; f[maxn];void dfs(int u, int last) &#123; sz[u] = 1; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(v != last) &#123; dfs(v, u); sz[u] += sz[v]; if(sz[v] &gt; sz[son[u]]) &#123; son[u] = v; &#125; &#125; &#125; &#125;void update(int u, int last, int t) &#123; int &amp;c = cou[a[u]]; --f[c].first; f[c].second -= a[u]; c += t; ++f[c].first; f[c].second += a[u]; if(t == 1) &#123; Max = max(Max, c); &#125; else if(!f[Max].first) &#123; --Max; &#125; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(v != last &amp;&amp; !big[v]) &#123; update(v, u, t); &#125; &#125;&#125;void dfs(int u, int last, int t) &#123; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(v == last || v == son[u]) &#123; continue; &#125; dfs(v, u, 0); &#125; if(son[u]) &#123; big[son[u]] = 1; dfs(son[u], u, 1); &#125; update(u, last, 1); big[son[u]] = 0; ans[u] = f[Max].second; if(!t) &#123; update(u, last, -1); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;a[i]); &#125; for(int i = 1; i &lt; n; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); dfs(1, 0, 1); for(int i = 1; i &lt;= n; ++i) &#123; printf("%lld ", ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>启发式合并</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 333E] Summer Earnings]]></title>
    <url>%2F2018%2F05%2F04%2FCodeforces-333E-Summer-Earnings%2F</url>
    <content type="text"><![CDATA[Description:选出三个点使得最小距离最大。 Solution:两两距离从大到小排序，用bitset判断两点是否同时连向第三点，如果有则是答案。 Code:12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3005;struct data &#123; int a, b; double d; data() &#123;&#125; data(int _a, int _b, double _d) : a(_a), b(_b), d(_d) &#123;&#125; bool friend operator &lt; (const data &amp;a, const data &amp;b) &#123; return a.d &gt; b.d; &#125;&#125; s[maxn * maxn];int n, tot;double l, r, ans;bitset&lt;maxn&gt; a[maxn];double x[maxn], y[maxn];double dis(int i, int j) &#123; return (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%lf%lf", &amp;x[i], &amp;y[i]); &#125; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = i + 1; j &lt;= n; ++j) &#123; s[++tot] = data(i, j, dis(i, j)); &#125; &#125; sort(s + 1, s + tot + 1); for(int i = 1; i &lt;= tot; ++i) &#123; if((a[s[i].a] &amp; a[s[i].b]).count()) &#123; printf("%.6f\n", sqrt(s[i].d) / 2); return 0; &#125; a[s[i].a].set(s[i].b); a[s[i].b].set(s[i].a); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 115E] Linear Kingdom Races]]></title>
    <url>%2F2018%2F05%2F04%2FCodeforces-115E-Linear-Kingdom-Races%2F</url>
    <content type="text"><![CDATA[Description:给出m段区间和n个点的花费，如果一个区间内的点全部被选中可以获得区间的价值。 Solution:一个简单的dp: dp[i]=max(dp[i-1], dp[j-1]+cost[j][i]+gain[j][i])考虑维护$gain$,每次加入一个区间的右端点时，线段树上$[0,l)$的区间加上价值，每次查询最大值即可获得答案。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; const int maxn = 2e5 + 5;struct data &#123; int l, r; ll v; bool friend operator &lt; (const data &amp;a, const data &amp;b) &#123; return a.r &lt; b.r; &#125;&#125; a[maxn];int n, m;ll dp[maxn], mx[maxn * 4], tag[maxn * 4], w[maxn];void pushdown(int x) &#123; tag[x &lt;&lt; 1] += tag[x]; tag[x &lt;&lt; 1 | 1] += tag[x]; mx[x &lt;&lt; 1] += tag[x]; mx[x &lt;&lt; 1 | 1] += tag[x]; tag[x] = 0;&#125;void update(int l, int r, int x, int a, int b, ll d) &#123; if(l &gt; b || r &lt; a) &#123; return; &#125; if(l &gt;= a &amp;&amp; r &lt;= b) &#123; tag[x] += d; mx[x] += d; return; &#125; pushdown(x); int mid = (l + r) &gt;&gt; 1; update(l, mid, x &lt;&lt; 1, a, b, d); update(mid + 1, r, x &lt;&lt; 1 | 1, a, b, d); mx[x] = max(mx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%lld", &amp;w[i]); &#125; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%lld", &amp;a[i].l, &amp;a[i].r, &amp;a[i].v); &#125; sort(a + 1, a + m + 1); for(int i = 1, j = 0; i &lt;= n; ++i) &#123; update(0, n, 1, 0, i - 1, -w[i]); while(j &lt; m &amp;&amp; a[j + 1].r == i) &#123; ++j; update(0, n, 1, 0, a[j].l - 1, a[j].v); &#125; dp[i] = max(dp[i - 1], mx[1]); update(0, n, 1, i, i, dp[i]); &#125; printf("%lld\n", dp[n]); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 4712] 洪水]]></title>
    <url>%2F2018%2F05%2F04%2Fbzoj-4712-%E6%B4%AA%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[Description:求将树上叶子全部截断的最小花费，可以修改点权。 Solution:基于链分治的动态$dp$。如果静态可以得出 f[u] = min(w[u], \sum{f[v]})如果把这个问题搬到序列上就是线段树区间最大值，树上继续沿用这个思想。先将树轻重链剖分，设g[u]表示轻儿子的f和，那么我们得出 f[u] = max(w[u], f[son[u]] + g[u])想象一下，一条重链的方案是一个点封上后面加上连续的g值。线段树维护一下$(f, sum)$,那么线段树上合并两端区间即是$(min(f_l, f_r + sum_l, sum_l + sum_r)$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 2e5 + 5;struct node &#123; ll sum, dp; node() &#123;&#125; node(ll _sum, ll _dp) : sum(_sum), dp(_dp) &#123;&#125; node friend operator + (const node &amp;a, const node &amp;b) &#123; return node(a.sum + b.sum, min(b.dp + a.sum, a.dp)); &#125;&#125; t[maxn * 4], ww[maxn];int n, q, dfs_clock;int dfn[maxn], fa[maxn], top[maxn], bot[maxn], son[maxn], sz[maxn];ll f[maxn], g[maxn], w[maxn];vector&lt;int&gt; G[maxn];void dfs(int u, int f) &#123; sz[u] = 1; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(v == f) &#123; continue; &#125; fa[v] = u; dfs(v, u); sz[u] += sz[v]; if(sz[v] &gt; sz[son[u]]) &#123; son[u] = v; &#125; &#125;&#125;void dfs(int u, int last, int t) &#123; top[u] = t; dfn[u] = ++dfs_clock; ll s = 0; f[u] = w[u]; if(son[u]) &#123; dfs(son[u], u, t); bot[u] = bot[son[u]]; &#125; else &#123; bot[u] = u; &#125; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(v == last || v == son[u]) &#123; continue; &#125; dfs(v, u, v); g[u] += f[v]; &#125; if(son[u]) &#123; f[u] = min(f[u], f[son[u]] + g[u]); &#125; ww[dfn[u]] = node(g[u], w[u]);&#125;namespace seg &#123; void build(int l, int r, int x) &#123; if(l == r) &#123; t[x] = ww[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, x &lt;&lt; 1); build(mid + 1, r, x &lt;&lt; 1 | 1); t[x] = t[x &lt;&lt; 1] + t[x &lt;&lt; 1 | 1]; &#125; node query(int l, int r, int x, int a, int b) &#123; if(l &gt;= a &amp;&amp; r &lt;= b) &#123; return t[x]; &#125; int mid = (l + r) &gt;&gt; 1; if(mid &lt; a) &#123; return query(mid + 1, r, x &lt;&lt; 1 | 1, a, b); &#125; else if(mid + 1 &gt; b) &#123; return query(l, mid, x &lt;&lt; 1, a, b); &#125; return query(l, mid, x &lt;&lt; 1, a, b) + query(mid + 1, r, x &lt;&lt; 1 | 1, a, b); &#125; void add(int l, int r, int x, int p, ll d) &#123; if(l == r) &#123; t[x].dp += d; return; &#125; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) &#123; add(l, mid, x &lt;&lt; 1, p, d); &#125; else &#123; add(mid + 1, r, x &lt;&lt; 1 | 1, p, d); &#125; t[x] = t[x &lt;&lt; 1] + t[x &lt;&lt; 1 | 1]; &#125; void pt(int l, int r, int x, int p, ll d) &#123; if(l == r) &#123; t[x].sum += d; return; &#125; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) &#123; pt(l, mid, x &lt;&lt; 1, p, d); &#125; else &#123; pt(mid + 1, r, x &lt;&lt; 1 | 1, p, d); &#125; t[x] = t[x &lt;&lt; 1] + t[x &lt;&lt; 1 | 1]; &#125; void modify(int x, ll d) &#123; int y = x; while(x) &#123; node t1 = query(1, n, 1, dfn[top[x]], dfn[bot[x]]); if(x == y) &#123; add(1, n, 1, dfn[x], d); &#125; else &#123; pt(1, n, 1, dfn[x], d); &#125; d = query(1, n, 1, dfn[top[x]], dfn[bot[x]]).dp - t1.dp; x = fa[top[x]]; &#125; &#125;&#125; using namespace seg; int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%lld", &amp;w[i]); &#125; for(int i = 1; i &lt; n; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); dfs(1, 0, 1); build(1, n, 1); scanf("%d", &amp;q); while(q--) &#123; char opt[10]; int x; ll d; scanf("%s%d", opt, &amp;x); if(opt[0] == 'Q') &#123; printf("%lld\n", query(1, n, 1, dfn[x], dfn[bot[x]]).dp); &#125; else &#123; scanf("%lld", &amp;d); modify(x, d); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 256E] Lucky Arrays]]></title>
    <url>%2F2018%2F05%2F04%2FCodeforces-256E-Lucky-Arrays%2F</url>
    <content type="text"><![CDATA[Description:给出一个$3*3$的矩阵，如果$(i,j)=1$表示数对$(i,j)$是好的。给出一个长为$n$初始全为$0$的序列，每次修改一个位置的值。可以把$0$的位置修改成其他值，问多少种可能的序列使得相邻的数对都是好的。 Solution:线段树维护区间$a[i][j]$表示值$i$为区间开头值$j$为区间结尾的方案数。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std; const int maxn = 1e5 + 5, P = 777777777;int n, m;int t[maxn * 4][4][4], a[4][4];void u(int x) &#123; memset(t[x], 0, sizeof(t[x])); for(int i = 1; i &lt;= 3; ++i) &#123; for(int j = 1; j &lt;= 3; ++j) &#123; if(a[i][j]) &#123; for(int c = 1; c &lt;= 3; ++c) &#123; for(int d = 1; d &lt;= 3; ++d) &#123; t[x][c][d] = (t[x][c][d] + 1LL * t[x &lt;&lt; 1][c][i] * t[x &lt;&lt; 1 | 1][j][d]) % P; &#125; &#125; &#125; &#125; &#125; &#125;void build(int l, int r, int x) &#123; if(l == r) &#123; t[x][1][1] = t[x][2][2] = t[x][3][3] = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, x &lt;&lt; 1); build(mid + 1, r, x &lt;&lt; 1 | 1); u(x);&#125;void update(int l, int r, int x, int p, int d) &#123; if(l == r) &#123; memset(t[x], 0, sizeof(t[x])); if(d) &#123; t[x][d][d] = 1; &#125; else &#123; t[x][1][1] = t[x][2][2] = t[x][3][3] = 1; &#125; return; &#125; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) &#123; update(l, mid, x &lt;&lt; 1, p, d); &#125; else &#123; update(mid + 1, r, x &lt;&lt; 1 | 1, p, d); &#125; u(x);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= 3; ++i)&#123; for(int j = 1; j &lt;= 3; ++j) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; build(1, n, 1); while(m--) &#123; int p, d, ans = 0; scanf("%d%d", &amp;p, &amp;d); update(1, n, 1, p, d); for(int i = 1; i &lt;= 3; ++i) &#123; for(int j = 1; j &lt;= 3; ++j) &#123; ans = (ans + t[1][i][j]) % P; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 46E] Comb]]></title>
    <url>%2F2018%2F05%2F04%2FCodeforces-46E-Comb%2F</url>
    <content type="text"><![CDATA[Description:给出一个$n×m$的矩阵，要求从第$i$行选取前$c_i$个元素，满足$c_i&gt;0$,$c1&gt;c2&lt;$$c3&gt;c4…$，问所选元素和最大值。 Solution:$dp[i][j]$表示第$i$行选择了前$j$个元素，前缀和优化即可。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1505;int n, m;ll dp[maxn][maxn], p[maxn][maxn], sum[maxn][maxn];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; ll x; scanf("%lld", &amp;x); sum[i][j] = sum[i][j - 1] + x; &#125; &#125; for(int i = 1; i &lt;= n; ++i) &#123; p[i][0] = p[i][m + 1] = -1LL &lt;&lt; 60; for(int j = 1; j &lt;= m; ++j) &#123; if(i &amp; 1) &#123; dp[i][j] = p[i - 1][j - 1] + sum[i][j]; &#125; else &#123; dp[i][j] = p[i - 1][j + 1] + sum[i][j]; &#125; &#125; if(i &amp; 1) &#123; for(int j = m; j; --j) &#123; p[i][j] = max(dp[i][j], p[i][j + 1]); &#125; &#125; else &#123; for(int j = 1; j &lt;= m; ++j) &#123; p[i][j] = max(dp[i][j], p[i][j - 1]); &#125; &#125; &#125; ll ans = -1LL &lt;&lt; 60; for(int i = 1; i &lt;= m; ++i) &#123; ans = max(ans, dp[n][i]); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 213E] Two Permutations]]></title>
    <url>%2F2018%2F05%2F03%2FCodeforces-213E-Two-Permutations%2F</url>
    <content type="text"><![CDATA[Description:给出两个长度分别为$n$和$m(n \leq m)$的排列，可以把第一个序列整体加上$d$，问多少个$d(d \geq 0)$使第一个序列为第二个序列的连续子序列? Solution:对于一个序列，我们找出在另一个序列的对应位置判断相同。这个过程可以用哈希完成。线段树维护哈希值，按照值的大小把对应下标加入线段树，动态维护即可。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5 + 5, B = 19992147;int n, m, ans;ll t, s;int pos[maxn], sz[maxn * 4];ll pw[maxn], h[maxn * 4];void update(int l, int r, int x, int p, int f, int d) &#123; if(l == r) &#123; sz[x] += f; h[x] += f * d; return; &#125; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) &#123; update(l, mid, x &lt;&lt; 1, p, f, d); &#125; else &#123; update(mid + 1, r, x &lt;&lt; 1 | 1, p, f, d); &#125; sz[x] = sz[x &lt;&lt; 1] + sz[x &lt;&lt; 1 | 1]; h[x] = h[x &lt;&lt; 1] * pw[sz[x &lt;&lt; 1 | 1]] + h[x &lt;&lt; 1 | 1];&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); pw[0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; int x; scanf("%d", &amp;x); t = t * B + x; pw[i] = pw[i - 1] * B; s += pw[i - 1]; &#125; for(int i = 1; i &lt;= m; ++i) &#123; int x; scanf("%d", &amp;x); pos[x] = i; &#125; for(int i = 1; i &lt;= m; ++i) &#123; update(1, m, 1, pos[i], 1, i); if(i &gt;= n) &#123; if(h[1] == t + (i - n) * s) &#123; ++ans; &#125; update(1, m, 1, pos[i - n + 1], -1, i - n + 1); &#125; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces 425E] Sereja and Sets]]></title>
    <url>%2F2018%2F05%2F03%2FCodeforces-425E-Sereja-and-Sets%2F</url>
    <content type="text"><![CDATA[Description:集合$S$包含$m$个区间$[l_i, r_i]$$(1 \leq l_i \leq r_i \leq n)$, 设$f(S)$表示最多能从$m$个区间中选出几个。给出$n$和$k$，问多少个集合$S$满足$f(S)=k$。 Solution:如果给出区间，只要按右端点排序贪心即可。考虑$dp[i][j]$表示最右不超过$i$，$f(S)=j$的方案数，由$dp[k][j-1]$转移过来。要多添加一个区间，那么这条线段右端点一定在$[k+1,i]$中，一共有$2^{i-k}-1$种选择方法，然后可以随意添加一些线段，必须保证和之前相交，有$2^{k*(i-k)}$种可能。 Code:12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;const int maxn = 505, P = 1e9 + 7;int n, m;ll dp[maxn][maxn], bin[maxn * maxn];int main() &#123; scanf("%d%d", &amp;n, &amp;m); bin[0] = 1; for(int i = 1; i &lt;= n * n; ++i) &#123; bin[i] = bin[i - 1] * 2 % P; &#125; for(int i = 0; i &lt;= n; ++i) &#123; dp[i][0] = 1; &#125; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= min(m, i); ++j) &#123; for(int k = j - 1; k &lt;= i; ++k) &#123; dp[i][j] = (dp[i][j] + dp[k][j - 1] * (bin[i - k] - 1) % P * bin[k * (i - k)] % P) % P; &#125; &#125; &#125; printf("%lld\n", dp[n][m]); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 3772] 精神污染]]></title>
    <url>%2F2018%2F05%2F03%2Fbzoj-3772-%E7%B2%BE%E7%A5%9E%E6%B1%A1%E6%9F%93%2F</url>
    <content type="text"><![CDATA[Description:给出$n$个点的树，$m$条路径，问一条路经包含另一条路径的概率。 Solution:考虑一条路径何时被另一条路经包含。如果这条路径不在端点$lca$处拐弯，那么另一条路经的端点分别在较深的端点的子树内和另一个端点的子树外。如果在$lca$处拐弯则两个端点都在子树内即可。转化为$dfs$序区间，发现是二维数点问题，扫描线即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 1e5 + 5;struct data &#123; int x, y, v; data() &#123;&#125; data(int _x, int _y, int _v) : x(_x), y(_y), v(_v) &#123;&#125; bool friend operator &lt; (const data &amp;a, const data &amp;b) &#123; return a.x &lt; b.x; &#125;&#125; q[maxn * 6], a[maxn * 2];int n, tot, m, dfs_clock;int t[maxn], in[maxn], out[maxn], dep[maxn], fa[maxn][19];vector&lt;int&gt; G[maxn];long long gcd(long long a, long long b) &#123; return !b ? a : gcd(b, a % b);&#125;void add(int p) &#123; for(; p &lt;= n; p += p &amp; -p) &#123; ++t[p]; &#125;&#125;int query(int p) &#123; int ret = 0; for(; p; p -= p &amp; -p) &#123; ret += t[p]; &#125; return ret;&#125;void dfs(int u, int last) &#123; in[u] = ++dfs_clock; for(int i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i]; if(v == last) &#123; continue; &#125; dep[v] = dep[u] + 1; fa[v][0] = u; dfs(v, u); &#125; out[u] = dfs_clock;&#125;int lca(int u, int v) &#123; if(dep[u] &lt; dep[v]) &#123; swap(u, v); &#125; int d = dep[u] - dep[v]; for(int i = 18; ~i; --i) &#123; if(d &gt;&gt; i &amp; 1) &#123; u = fa[u][i]; &#125; &#125; if(u == v) &#123; return u; &#125; for(int i = 18; ~i; --i) &#123; if(fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; &#125; return fa[u][0];&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt; n; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); for(int j = 1; j &lt;= 18; ++j) &#123; for(int i = 1; i &lt;= n; ++i) &#123; fa[i][j] = fa[fa[i][j - 1]][j - 1]; &#125; &#125; for(int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); a[i] = data(in[u], in[v], 0); a[i + m] = data(in[v], in[u], 0); if(dep[u] &lt; dep[v]) &#123; swap(u, v); &#125; int t; if(dep[lca(u, v)] == dep[v]) &#123; int t = u; for(int i = 18; ~i; --i) &#123; if(dep[fa[t][i]] &gt; dep[v]) &#123; t = fa[t][i]; &#125; &#125; /* [in[u], out[u]] [1, in[v] - 1] [in[u], out[u]] [out[v] + 1, n] */ v = t; q[++tot] = data(out[u], in[v] - 1, 1); q[++tot] = data(in[u] - 1, in[v] - 1, -1); q[++tot] = data(out[u], n, 1); q[++tot] = data(in[u] - 1, n, -1); q[++tot] = data(out[u], out[v], -1); q[++tot] = data(in[u] - 1, out[v], 1); &#125; else &#123; q[++tot] = data(out[u], out[v], 1); q[++tot] = data(out[u], in[v] - 1, -1); q[++tot] = data(in[u] - 1, out[v], -1); q[++tot] = data(in[u] - 1, in[v] - 1, 1); &#125; &#125; sort(q + 1, q + tot + 1); sort(a + 1, a + 2 * m + 1); long long t = 1LL * m * (m - 1) / 2, ans = 0; for(int i = 1, j = 0; i &lt;= tot; ++i) &#123; while(j &lt; 2 * m &amp;&amp; a[j + 1].x &lt;= q[i].x) &#123; ++j; add(a[j].y); &#125; ans += q[i].v * query(q[i].y); &#125; ans -= m; printf("%lld/%lld\n", ans / gcd(ans, t), t / gcd(ans, t)); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 2677] tied]]></title>
    <url>%2F2018%2F05%2F03%2Fbzoj-2677-tied%2F</url>
    <content type="text"><![CDATA[Description:给出$n$个$x$坐标相同的柱子，一条狗位于柱子的右边，一条线出发于狗又回到狗。问删掉几个柱子可以让狗一直跑。 Solution:我们可以发现，如果一条线段从两个柱子中间穿入又穿出是无效的。所以我们把每条线段编号为上方的柱子的编号，然后枚举柱子，再维护一个栈，每次按照给出的顺序加入栈，如果和栈顶一样弹出。最后栈为空则可以。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct P &#123; double x, y; P() &#123;&#125; P(double _x, double _y) : x(_x), y(_y) &#123;&#125; double friend operator * (const P &amp;a, const P &amp;b) &#123; return a.x * b.y - a.y * b.x; &#125; P friend operator - (const P &amp;a, const P &amp;b) &#123; return P(a.x - b.x, a.y - b.y); &#125; bool friend operator &lt; (const P &amp;a, const P &amp;b) &#123; return a.y &lt; b.y; &#125;&#125; a[13], p[10005];int n, m, ans, tot;double sx, sy;int pos[10005], mk[10005], st[10005];int main() &#123; scanf("%d%d%lf%lf", &amp;n, &amp;m, &amp;sx, &amp;sy); for(int i = 0; i &lt; n; ++i) &#123; scanf("%lf%lf", &amp;a[i].x, &amp;a[i].y); &#125; for(int i = 0; i &lt;= m; ++i) &#123; scanf("%lf%lf", &amp;p[i].x, &amp;p[i].y); &#125; sort(a, a + n); for(int i = 0, j; i &lt; m; ++i) &#123; if((p[i].x &gt; a[0].x) ^ (p[i + 1].x &gt; a[0].x)) &#123; if(p[i].x &gt; p[i + 1].x) &#123; for(j = 0; j &lt; n &amp;&amp; (p[i + 1] - p[i]) * (a[j] - p[i]) &gt; 0; ++j); &#125; else &#123; for(j = n; j &amp;&amp; (p[i + 1] - p[i]) * (a[j - 1] - p[i]) &gt; 0; --j); &#125; pos[++tot] = j; &#125; &#125; for(int S = 1; S &lt; 1 &lt;&lt; n; ++S) &#123; int k = 0, top = 0; for(int i = 0; i &lt; n; ++i) &#123; if(S &gt;&gt; i &amp; 1) &#123; ++k; &#125; mk[i + 1] = k; &#125; for(int i = 1; i &lt;= tot; ++i) &#123; if(!top || st[top] != mk[pos[i]]) &#123; st[++top] = mk[pos[i]]; &#125; else &#123; --top; &#125; &#125; if(!top) &#123; ans = max(ans, __builtin_popcount(S)); &#125; &#125; printf("%d\n", n - ans); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
</search>
